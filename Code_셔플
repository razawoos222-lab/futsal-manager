
const CONFIG = {
  STATS_SHEET: "선수별능력치", // 선수들의 기본 능력치 (공격, 수비, 포지션)가 기록된 시트 이름
  PLAYER_ARCHIVE_SHEET: "기록실_개인기록", // 개인별 경기 기록이 누적되는 시트 이름
  PAST_TEAMS_SHEET: "지난_팀_구성", // 과거 경기에서 팀 구성이 기록될 시트 이름
  APP_STATE_SHEET: "앱_상태_저장" 
};


let batchSaveTimer = null;
let lastBatchSave = 0;

// --- 웹 앱 진입점 ---
// 웹 앱이 처음 로드될 때 실행되는 함수입니다.
function doGet(e) {
  // 'index' HTML 파일을 웹 페이지로 변환하여 반환합니다.
  // 페이지 제목을 '풋살 매니저 (업그레이드)'로 설정합니다.
  return HtmlService.createHtmlOutputFromFile('index').setTitle('JMFC풋살 매니저');
}


// --- 안전 실행 래퍼 ---
// 서버 함수 호출 시 동시성 문제를 방지하고 오류를 처리하는 래퍼 함수입니다.
function safeExecute(func, ...args) {
  const lock = LockService.getScriptLock(); // 스크립트 잠금 객체를 가져옵니다.
  lock.waitLock(30000); // 다른 실행이 완료될 때까지 최대 30초 대기합니다.
  try {
    const result = func(...args); // 전달된 함수를 실행합니다.
    return { success: true, data: result }; // 성공 시 성공 상태와 결과 데이터를 반환합니다.
  } catch (e) {
    // 오류 발생 시 오류 메시지와 스택 트레이스를 기록합니다.
    Logger.log(`오류 발생: ${e.message}\n${e.stack}`);
    // 실패 시 실패 상태와 오류 메시지를 반환합니다.
    return { success: false, message: e.message };
  } finally {
    lock.releaseLock(); // 작업이 완료되면 잠금을 해제합니다.
  }
}


// --- 데이터 소스 및 상태 관리 ---
// 앱의 초기 데이터를 가져오는 함수입니다. (웹 앱 로드 시 호출)
function getInitialData() {
  // 마스터 선수 목록, 현재 앱 상태, 선수별 누적 기록을 가져와 반환합니다.
  return safeExecute(() => ({
    masterPlayers: getMasterPlayersFromSheet(), // 선수별 능력치 시트에서 마스터 선수 목록 가져오기
    appState: getAppState(), // 캐시에서 현재 앱 상태 가져오기 (없으면 초기 상태 생성)
    playerArchiveStats: getPlayerStatsFromArchive() // 선수별 누적 기록 가져오기
  }));
}


// 1. getMasterPlayersFromSheet 최적화
function getMasterPlayersFromSheet() {
  const sheet = getSheet(CONFIG.STATS_SHEET);
  if (sheet.getLastRow() < 2) return [];
  
  // ★ 필요한 컬럼만 정확히 읽기 (20개 → 8개)
  const ranges = [
    sheet.getRange(2, 1, sheet.getLastRow() - 1, 4), // A-D (이름,포지션,공격,수비)
    sheet.getRange(2, 14, sheet.getLastRow() - 1, 1), // N (승률)  
    sheet.getRange(2, 15, sheet.getLastRow() - 1, 1), // O (CCP)
    sheet.getRange(2, 19, sheet.getLastRow() - 1, 1), // S (MP)
    sheet.getRange(2, 20, sheet.getLastRow() - 1, 1)  // T (MP/G)
  ];
  
  // 한번에 읽기
  const [basicData, winRateData, ccpData, mpData, mpPerGameData] = ranges.map(r => r.getValues());
  
  return basicData.map((row, i) => ({
    name: row[0],
    position: row[1], 
    att: Number(row[2]) || 5,
    def: Number(row[3]) || 5,
    winRate: Number(winRateData[i][0]) || 0,
    ccp: Number(ccpData[i][0]) || 0,
    mp: Number(mpData[i][0]) || 0,
    mpPerGame: Number(mpPerGameData[i][0]) || 0
  })).filter(p => p.name);
}


// =================================================================
// 파일: Code.gs | 1.1 | 함수 수정: getAppState
// =================================================================
// 앱 상태를 스프레드시트에서 가져오기
function getAppState() {
  const sheet = getSheet(CONFIG.APP_STATE_SHEET);
  
  // A1 셀에서 JSON 데이터 읽기
  const stateString = sheet.getRange('A1').getValue();
  
  if (stateString) {
    try {
      const parsedState = JSON.parse(stateString);
  
      parsedState.selectedDate = parsedState.selectedDate ||
      Utilities.formatDate(new Date(), SpreadsheetApp.getActive().getSpreadsheetTimeZone(), "yyyy-MM-dd");
      parsedState.match.selectedDuration = parsedState.match.selectedDuration || 600; // 기본 10분 (600초)
      parsedState.selectedField = parsedState.selectedField || 'A 구장'; // 선택된 구장명 초기화
       // 원팀 데이터 저장을 위한 필드 추가
      parsedState.originalTeams = parsedState.originalTeams || null;

      if (!parsedState.sessionStats.playerStats) parsedState.sessionStats.playerStats = {};
      parsedState.attendingPlayerNames.forEach(pName => {
        if (!parsedState.sessionStats.playerStats[pName]) {
          parsedState.sessionStats.playerStats[pName] = { goal: 0, assist: 0, defense: 0, save: 0, gamesPlayed: 0, wins: 0, draws: 0, losses: 0 };
        }
      });
      if (!parsedState.teams.RED.players && Array.isArray(parsedState.teams.RED)) parsedState.teams.RED = { players: parsedState.teams.RED, goalkeeper: null };
      if (!parsedState.teams.BLUE.players && Array.isArray(parsedState.teams.BLUE)) parsedState.teams.BLUE = { players: parsedState.teams.BLUE, goalkeeper: null };
      if (!parsedState.teams.YELLOW.players && Array.isArray(parsedState.teams.YELLOW)) parsedState.teams.YELLOW = { players: parsedState.teams.YELLOW, goalkeeper: null };
      parsedState.match.todayHeadToHead = parsedState.match.todayHeadToHead || {};
      
      // ▼▼▼ [핵심 수정] matchHistory 배열을 추가하고 초기화합니다. ▼▼▼
      parsedState.sessionResults = parsedState.sessionResults || { matchHistory: [] }; 
      if (!parsedState.sessionResults.matchHistory) {
        parsedState.sessionResults.matchHistory = [];
      }
      // ▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲
      
      parsedState.match.nextMatchSuggestion = parsedState.match.nextMatchSuggestion || null;

     return parsedState;
    } catch(e) {
      Logger.log("손상된 저장 데이터를 삭제하고 새 상태로 시작합니다.");
      sheet.clear();
    }
  }

 // 초기 상태 생성
  const teamStatTemplate = { wins: 0, draws: 0, losses: 0, consecutiveMatches: 0, goalsFor: 0, goalsAgainst: 0, matchesPlayed: 0, consecutivePlays: 0 };
  const initialState = {
    currentScreen: 'screen-attendance',
    selectedDate: Utilities.formatDate(new Date(), SpreadsheetApp.getActive().getSpreadsheetTimeZone(), "yyyy-MM-dd"),
    selectedField: 'A 구장',
    attendingPlayerNames: [],
    teams: {
      RED: { players: [], goalkeeper: null },
      BLUE: { players: [], goalkeeper: null },
      YELLOW: { players: [], goalkeeper: null }
    },
    originalTeams: null, // 원팀 데이터 저장용
    match: {
      count: 1,
      playingTeams: [],
      teamA: { name: '', score: 0 },
      teamB: { name: '', score: 0 },
      timeline: [],
      seconds: 600,
      timerRunning: false,
      selectedDuration: 600,
      todayHeadToHead: {}
    },
    sessionStats: {
      playerStats: {},
      teamStats: { RED: {...teamStatTemplate}, BLUE: {...teamStatTemplate}, YELLOW: {...teamStatTemplate} }
    },
    sessionResults: { 
      matchHistory: [] 
    }
  };
  
  saveAppState(initialState);
  return initialState;
}

// 앱 상태를 스프레드시트에 저장
function saveAppState(state) {
  const sheet = getSheet(CONFIG.APP_STATE_SHEET);
  const jsonString = JSON.stringify(state);
  
  // A1 셀에 JSON 저장
  sheet.getRange('A1').setValue(jsonString);
  
  // B1 셀에 최종 저장 시간 기록 (디버깅용)
  sheet.getRange('B1').setValue(new Date().toLocaleString('ko-KR'));
}


// 세션 초기화 (시트 데이터 삭제)
function resetSession() {
  return safeExecute(() => {
    const sheet = getSheet(CONFIG.APP_STATE_SHEET);
    sheet.clear(); // 시트 내용 삭제
    return getAppState(); // 새로운 초기 상태 반환
  });
}

// 원팀 저장 함수 (새로 추가)
function saveOriginalTeams() {
  return safeExecute(() => {
    const state = getAppState();
    
    // 원팀이 아직 저장되지 않았다면 현재 팀을 원팀으로 저장
    if (!state.originalTeams) {
      state.originalTeams = JSON.parse(JSON.stringify(state.teams));
      Logger.log("원팀 구성이 저장되었습니다.");
    }
    
    saveAppState(state);
    return state;
  });
}

// 원팀 복구 함수 (새로 추가)
function restoreOriginalTeams() {
  return safeExecute(() => {
    const state = getAppState();
    
    if (state.originalTeams) {
      state.teams = JSON.parse(JSON.stringify(state.originalTeams));
      Logger.log("원팀 구성으로 복구되었습니다.");
      saveAppState(state);
    }
    
    return state;
  });
}

// 현재 화면을 변경하고 앱 상태를 저장하는 함수입니다.
function changeScreen(id) {
  return safeExecute(() => {
    const s = getAppState(); // 현재 앱 상태를 가져옵니다.
    s.currentScreen = id; // 화면 ID를 업데이트합니다.
    saveAppState(s); // 변경된 상태를 저장합니다.
    return s; // 업데이트된 상태를 반환합니다.
  });
}


// 스프레드시트에서 특정 시트를 가져오거나 없으면 새로 생성하는 함수입니다.
function getSheet(sheetName) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  return ss.getSheetByName(sheetName) || ss.insertSheet(sheetName); // 시트를 찾거나 새로 만듭니다.
}


// 참석자 목록을 앱 상태에 저장하고 선택된 날짜를 업데이트하는 함수입니다.
function setAttendingPlayersAndDate(playerNames, selectedDate) {
  return safeExecute(() => {
    const state = getAppState(); // 현재 앱 상태를 가져옵니다.
    // [오류 수정] playerNames가 유효한 배열인지 확인
    if (!Array.isArray(playerNames)) {
      Logger.log("오류: setAttendingPlayersAndDate에 유효하지 않은 playerNames가 전달되었습니다.");
      throw new Error("참석자 목록 데이터가 유효하지 않습니다.");
    }


    state.attendingPlayerNames = playerNames; // 참석자 이름을 업데이트합니다.
    state.selectedDate = selectedDate; // 선택된 날짜를 업데이트합니다.
   
    // 참석자 목록이 변경되면 playerStats의 초기화도 다시 수행 (새로운 참석자 추가 등)
    playerNames.forEach(pName => {
      if (!state.sessionStats.playerStats[pName]) {
        state.sessionStats.playerStats[pName] = { goal: 0, assist: 0, defense: 0, save: 0, gamesPlayed: 0, wins: 0, draws: 0, losses: 0 };
      }
    });


    saveAppState(state); // 변경된 상태를 저장합니다.
    return state; // 업데이트된 상태를 반환합니다.
  });
}


// '지난_팀_구성' 시트에서 과거 팀 구성 데이터를 가져오는 함수입니다.
function getPastTeamCompositions() {
  const sheet = getSheet(CONFIG.PAST_TEAMS_SHEET); // '지난_팀_구성' 시트를 가져옵니다.
  if (sheet.getLastRow() < 2) return []; // 데이터가 없으면 빈 배열 반환
 
  // 첫 행이 비어있으면 헤더를 추가합니다. (혹시 모를 경우를 대비한 안전 장치)
  if (sheet.getRange(1, 1).getValue() === "") {
    sheet.appendRow(["경기일", "경기번호", "팀명", "키퍼", "선수1", "선수2", "선수3", "선수4", "선수5", "선수6", "선수7"]); // 키퍼 컬럼 추가
    SpreadsheetApp.flush(); // 변경사항 즉시 반영
  }


  // 2행부터 마지막 행까지, 1열부터 마지막 열까지의 데이터를 가져옵니다.
  const data = sheet.getRange(2, 1, sheet.getLastRow() - 1, sheet.getLastColumn()).getValues();
 
  // 데이터를 파싱하여 [{matchDate, matchNumber, teamName, goalkeeper, players: []}] 형태로 반환합니다.
  return data.map(row => {
    const matchDate = row[0]; // 경기일
    const matchNumber = row[1]; // 경기 번호
    const teamName = row[2]; // 팀 이름
    const goalkeeper = row[3]; // 키퍼 이름 (신규)
    const players = row.slice(4).filter(p => p); // 선수 목록 (빈 값 제거, 키퍼 제외)
    return { matchDate, matchNumber, teamName, goalkeeper, players };
  });
}


// '기록실_개인기록' 시트에서 선수별 누적 데이터를 '합산'하여 가져오는 수정된 함수
function getPlayerStatsFromArchive() {
  const sheet = getSheet(CONFIG.PLAYER_ARCHIVE_SHEET);
  if (sheet.getLastRow() < 2) return {};


  if (sheet.getRange(1, 1).getValue() === "") {
    sheet.appendRow(["경기일", "선수명", "경기수", "승", "무", "패", "득점", "도움", "수비", "선방"]);
    SpreadsheetApp.flush();
  }
 
  const data = sheet.getRange(2, 2, sheet.getLastRow() - 1, 9).getValues();
 
  const playerStats = {};
  data.forEach(row => {
    const playerName = row[0];
    if (!playerStats[playerName]) {
      // 새로운 선수는 초기화
      playerStats[playerName] = { games: 0, wins: 0, draws: 0, losses: 0, goal: 0, assist: 0, defense: 0, save: 0 };
    }
    // 기존 데이터에 계속 합산
    playerStats[playerName].games += Number(row[1]) || 0;
    playerStats[playerName].wins += Number(row[2]) || 0;
    playerStats[playerName].draws += Number(row[3]) || 0;
    playerStats[playerName].losses += Number(row[4]) || 0;
    playerStats[playerName].goal += Number(row[5]) || 0;
    playerStats[playerName].assist += Number(row[6]) || 0;
    playerStats[playerName].defense += Number(row[7]) || 0;
    playerStats[playerName].save += Number(row[8]) || 0;
  });
  return playerStats;
}

function performTeamAllocation(algorithm, shuffleEnabled = false) {  // shuffleEnabled 파라미터 추가
  return safeExecute(() => {
    const state = getAppState();
    
    // 새로운 팀 배분 시 원팀 데이터 초기화
    state.originalTeams = null;
    
    // 시트에서 직접 계산된 데이터 가져오기 (빠르고 안정적)
    const masterPlayers = getMasterPlayersFromSheet();
    const attendingPlayersData = masterPlayers.filter(p => state.attendingPlayerNames.includes(p.name));
    
    // 알고리즘별 설정 (mixRatio 완전 제거)
    let criteria = 'sheet_only';
    let baseAlgorithm = algorithm;
    
    switch (algorithm) {
      case 'balanced':
      case 'snakeMethod':
      case 'random':
        criteria = 'sheet_only';
        break;
      case 'balanced_ccp':
        criteria = 'mixed_ccp';
        baseAlgorithm = 'balanced';
        break;
      case 'balanced_record':
        criteria = 'ccpBased';
        baseAlgorithm = 'balanced';
        break;
      case 'snake_ccp':
        criteria = 'mixed_ccp';
        baseAlgorithm = 'snakeMethod';
        break;
      case 'snake_record':
        criteria = 'ccpBased';
        baseAlgorithm = 'snakeMethod';
        break;
      case 'mpBased':
        criteria = 'mpBased';
        baseAlgorithm = 'balanced';
        break;
      case 'mpPerGameBased':
        criteria = 'mpPerGameBased';
        baseAlgorithm = 'balanced';
        break;
      case 'winRateBased':
        criteria = 'winRateBased';
        baseAlgorithm = 'balanced';
        break;
    }
    
   
    // 능력치 계산 (간단하고 명확하게)
    attendingPlayersData.forEach(p => {
      p.power = getPlayerPower(p, criteria);
    });

    // 티어 셔플 적용
    if (shuffleEnabled) {
      // 먼저 파워 순으로 정렬
      attendingPlayersData.sort((a, b) => b.power - a.power);
      
      // 3개 티어로 나누기
      const tierSize = Math.ceil(attendingPlayersData.length / 3);
      
      // 각 티어 내부 셔플
      for (let i = 0; i < attendingPlayersData.length; i += tierSize) {
        const tierEnd = Math.min(i + tierSize, attendingPlayersData.length);
        const tier = attendingPlayersData.slice(i, tierEnd);
        
        // Fisher-Yates 셔플 (더 균등한 랜덤)
        for (let j = tier.length - 1; j > 0; j--) {
          const randomIndex = Math.floor(Math.random() * (j + 1));
          [tier[j], tier[randomIndex]] = [tier[randomIndex], tier[j]];
        }
        
        // 셔플된 티어를 원래 위치에 다시 넣기
        attendingPlayersData.splice(i, tier.length, ...tier);
      }
    }
    
    

    let teams = {
      RED: { players: [], goalkeeper: null },
      BLUE: { players: [], goalkeeper: null },
      YELLOW: { players: [], goalkeeper: null }
    };
    const teamNames = Object.keys(teams);

    // 기본 알고리즘으로 배분
    switch (baseAlgorithm) {
      case 'snakeMethod':
        allocateSnakeMethod(attendingPlayersData, teams, teamNames);
        break;
      case 'balanced':
        allocateBalanced(attendingPlayersData, teams, teamNames);
        break;
      default: // 'random'
        allocateRandom(attendingPlayersData, teams, teamNames);
        break;
    }
    
    // 주장/부주장 설정
    assignCaptains(teams);
    
    // 최종 팀 데이터 설정
    state.teams = {
      RED: { players: teams.RED.players.map(p => p.name), goalkeeper: teams.RED.goalkeeper, captain: teams.RED.captain, viceCaptain: teams.RED.viceCaptain },
      BLUE: { players: teams.BLUE.players.map(p => p.name), goalkeeper: teams.BLUE.goalkeeper, captain: teams.BLUE.captain, viceCaptain: teams.BLUE.viceCaptain },
      YELLOW: { players: teams.YELLOW.players.map(p => p.name), goalkeeper: teams.YELLOW.goalkeeper, captain: teams.YELLOW.captain, viceCaptain: teams.YELLOW.viceCaptain }
    };

    state.currentScreen = 'screen-team-allocation';
    saveAppState(state);
    return state;
  });
}

function getHybridPlayerPower(player, actualStats, mixRatio, criteria) {
  const sheetPower = player.att + player.def; // 임의스탯 (공격+수비)

  if (mixRatio === 0 || criteria === 'sheet_only') {
    return sheetPower;
  }

  let actualPower = 0;
  switch (criteria) {
    case 'ccpBased':
      actualPower = player.ccp || 0;
      break;
    case 'mpBased':
      actualPower = player.mp || 0;
      break;
    case 'mpPerGameBased':
      actualPower = player.mpPerGame || 0;
      break;
    case 'winRateBased':
      actualPower = player.winRate || 0;
      break;
    default:
      actualPower = sheetPower;
      break;
  }
  
  return sheetPower * (1 - mixRatio) + actualPower * mixRatio;
}


// 경기 시작 함수 (경기 시간 설정 기능 및 구장명 추가)
function startMatch(teamNames, selectedDuration, selectedField) {
  return safeExecute(() => {
    const s = getAppState(); // 현재 앱 상태를 가져옵니다.

    // 첫 경기 시작 시 원팀 저장
    if (s.match.count === 1 && !s.originalTeams) {
      s.originalTeams = JSON.parse(JSON.stringify(s.teams));
    }

    // [오류 수정] teamNames가 유효한 배열인지 확인
    if (!Array.isArray(teamNames) || teamNames.length < 2) {
      Logger.log("오류: startMatch에 유효하지 않은 teamNames가 전달되었습니다.");
      throw new Error("경기 시작을 위한 팀 선택이 올바르지 않습니다.");
    }

    s.currentScreen = 'screen-match-controller'; // 경기 컨트롤러 화면으로 전환합니다.
    // 경기 정보를 초기화하고 설정합니다. (선택된 경기 시간 및 구장명 반영)
    s.match = {
      count: s.match.count,
      playingTeams: teamNames,
      teamA: { name: '', score: 0 }, // 팀 이름은 아래에서 설정
      teamB: { name: '', score: 0 }, // 팀 이름은 아래에서 설정
      timeline: [],
      seconds: selectedDuration, // 선택된 경기 시간으로 설정
      timerRunning: false, // 타이머 초기에는 정지 상태
      selectedDuration: selectedDuration, // 선택된 경기 시간 저장
      todayHeadToHead: s.match.todayHeadToHead || {}, // 오늘의 상대 전적 초기화 (기존 값 유지)
      field: selectedField // 선택된 구장명 저장
    };
    // 현재 경기 팀A, 팀B 이름 설정
    s.match.teamA.name = teamNames[0];
    s.match.teamB.name = teamNames[1];


    // 현재 참석자 중 세션 통계에 없는 플레이어의 초기 스탯을 설정합니다.
    s.attendingPlayerNames.forEach(pName => {
      if (!s.sessionStats.playerStats[pName]) {
        s.sessionStats.playerStats[pName] = { goal: 0, assist: 0, defense: 0, save: 0, gamesPlayed: 0, wins: 0, draws: 0, losses: 0 };
      }
    });
    saveAppState(s); // 변경된 상태를 저장합니다.
    return s; // 업데이트된 상태를 반환합니다.
  });
}

function recordEvent(eventData, seconds) {
  const outerStart = new Date().getTime();
  Logger.log('🔴 recordEvent 함수 시작');
  
  const result = safeExecute(() => {
    const innerStart = new Date().getTime();
    Logger.log('🟡 safeExecute 내부 시작');
    
    const s = getAppState();
    const getStateTime = new Date().getTime();
    Logger.log(`📖 getAppState 완료: ${getStateTime - innerStart}ms`);

    // 기존 로직... (동일)
    if (!s.match.timerRunning && s.match.seconds > 0) {
      throw new Error("경기가 시작되지 않았거나 일시정지 상태에서는 기록할 수 없습니다. 타이머를 시작해주세요.");
    }
    
    if (typeof seconds === 'number' && !isNaN(seconds)) {
        s.match.seconds = seconds;
    }

    const time = new Date().toLocaleTimeString('en-GB');
    s.match.timeline.unshift({ ...eventData, time });

    const { player, stat, teamName, assistPlayer } = eventData;

    if (s.sessionStats.playerStats[player]) {
      if (stat !== 'ownGoal') {
        s.sessionStats.playerStats[player][stat]++;
      }
    }
    if (stat === 'goal' && assistPlayer && s.sessionStats.playerStats[assistPlayer]) {
      s.sessionStats.playerStats[assistPlayer].assist++;
    }
   
    if (stat === 'goal') {
      const [teamToScore, teamToConcede] = teamName === s.match.teamA.name ? [s.match.teamA, s.match.teamB] : [s.match.teamB, s.match.teamA];
      teamToScore.score++;
      s.sessionStats.teamStats[teamToScore.name].goalsFor++;
      s.sessionStats.teamStats[teamToConcede.name].goalsAgainst++;
    } else if (stat === 'ownGoal') {
      const [scoringTeam, concedingTeam] = teamName === s.match.teamA.name ? [s.match.teamB, s.match.teamA] : [s.match.teamA, s.match.teamB];
      scoringTeam.score++;
      s.sessionStats.teamStats[scoringTeam.name].goalsFor++;
      s.sessionStats.teamStats[concedingTeam.name].goalsAgainst++;
    }

    const beforeSave = new Date().getTime();
    Logger.log(`⚙️ 로직 처리 완료: ${beforeSave - getStateTime}ms`);

    saveAppState(s);
    
    const afterSave = new Date().getTime();
    Logger.log(`💾 saveAppState 완료: ${afterSave - beforeSave}ms`);

    const innerEnd = new Date().getTime();
    Logger.log(`🟡 safeExecute 내부 완료: ${innerEnd - innerStart}ms`);
    
    return s;
  });

  const outerEnd = new Date().getTime();
  Logger.log(`🔴 recordEvent 함수 완료: ${outerEnd - outerStart}ms`);
  
  return result;
}

// 가장 최근 기록된 이벤트를 취소하는 함수
function undoLastEvent() {
  return safeExecute(() => {
    const s = getAppState();
    
    // 타임라인이 비어있으면 취소할 것이 없음
    if (!s.match.timeline || s.match.timeline.length === 0) {
      throw new Error("취소할 기록이 없습니다.");
    }
    
    // 가장 최근 이벤트 가져오기 (배열의 첫 번째 요소)
    const lastEvent = s.match.timeline[0];
    const { player, stat, teamName, assistPlayer } = lastEvent;
    
    // 선수 통계에서 해당 스탯 되돌리기
    if (s.sessionStats.playerStats[player] && stat !== 'ownGoal') {
      if (s.sessionStats.playerStats[player][stat] > 0) {
        s.sessionStats.playerStats[player][stat]--;
      }
    }
    
    // 도움이 있었던 득점의 경우 도움 선수의 assist 스탯도 되돌리기
    if (stat === 'goal' && assistPlayer && s.sessionStats.playerStats[assistPlayer]) {
      if (s.sessionStats.playerStats[assistPlayer].assist > 0) {
        s.sessionStats.playerStats[assistPlayer].assist--;
      }
    }
    
    // 득점/자책골 관련 팀 스코어 및 통계 되돌리기
    if (stat === 'goal') {
      // 일반 득점인 경우
      const [scoringTeam, concedingTeam] = teamName === s.match.teamA.name 
        ? [s.match.teamA, s.match.teamB] 
        : [s.match.teamB, s.match.teamA];
      
      // 팀 스코어 되돌리기
      if (scoringTeam.score > 0) {
        scoringTeam.score--;
      }
      
      // 팀 통계 되돌리기
      if (s.sessionStats.teamStats[scoringTeam.name].goalsFor > 0) {
        s.sessionStats.teamStats[scoringTeam.name].goalsFor--;
      }
      if (s.sessionStats.teamStats[concedingTeam.name].goalsAgainst > 0) {
        s.sessionStats.teamStats[concedingTeam.name].goalsAgainst--;
      }
      
    } else if (stat === 'ownGoal') {
      // 자책골인 경우 (자책골을 한 선수의 반대팀이 득점)
      const [scoringTeam, concedingTeam] = teamName === s.match.teamA.name 
        ? [s.match.teamB, s.match.teamA] 
        : [s.match.teamA, s.match.teamB];
      
      // 팀 스코어 되돌리기
      if (scoringTeam.score > 0) {
        scoringTeam.score--;
      }
      
      // 팀 통계 되돌리기
      if (s.sessionStats.teamStats[scoringTeam.name].goalsFor > 0) {
        s.sessionStats.teamStats[scoringTeam.name].goalsFor--;
      }
      if (s.sessionStats.teamStats[concedingTeam.name].goalsAgainst > 0) {
        s.sessionStats.teamStats[concedingTeam.name].goalsAgainst--;
      }
    }
    
    // 타임라인에서 해당 이벤트 제거
    s.match.timeline.shift();
    
    // 변경된 상태 저장
    saveAppState(s);
    
    Logger.log(`이벤트 취소 완료: ${player}의 ${stat} 기록이 취소되었습니다.`);
    return s;
  });
}

// =================================================================
// 파일: Code.gs | 1.2 | [속도 개선] 함수 수정: endMatch
// =================================================================
function endMatch() {
  return safeExecute(() => {
    const s = getAppState(); // 현재 앱 상태를 가져옵니다.
    const { teamA, teamB, count } = s.match;
    const teamStats = s.sessionStats.teamStats; // 세션 팀 통계
    const playerStats = s.sessionStats.playerStats; // 세션 선수 통계

    if (!teamA || !teamA.name || !teamB || !teamB.name) {
      throw new Error("경기 종료 처리를 위한 팀 정보가 부족합니다.");
    }

    // --- (여기부터) 승패 처리, 상대 전적 업데이트, 선수별 승무패 업데이트 등 ---
    // --- (이 부분의 기존 로직은 변경 없이 그대로 유지됩니다) ---
    if (teamA.score === teamB.score) {
      teamStats[teamA.name].draws++;
      teamStats[teamB.name].draws++;
    } else {
      const winner = teamA.score > teamB.score ? teamA.name : teamB.name;
      const loser = winner === teamA.name ? teamB.name : teamA.name;
      teamStats[winner].wins++;
      teamStats[loser].losses++;
    }
    const teamA_name = teamA.name;
    const teamB_name = teamB.name;
    const headToHeadKey = [teamA_name, teamB_name].sort().join('_');
    if (!s.match.todayHeadToHead[headToHeadKey]) {
      s.match.todayHeadToHead[headToHeadKey] = { [teamA_name]: { wins: 0, draws: 0, losses: 0 }, [teamB_name]: { wins: 0, draws: 0, losses: 0 } };
    }
    if (teamA.score === teamB.score) {
      s.match.todayHeadToHead[headToHeadKey][teamA_name].draws++;
      s.match.todayHeadToHead[headToHeadKey][teamB_name].draws++;
    } else {
      const winner = teamA.score > teamB.score ? teamA_name : teamB_name;
      const loser = winner === teamA.name ? teamB.name : teamA.name;
      s.match.todayHeadToHead[headToHeadKey][winner].wins++;
      s.match.todayHeadToHead[headToHeadKey][loser].losses++;
    }
    const allPlayersInMatch = [...s.teams[teamA.name].players, ...s.teams[teamB.name].players];
    const allGoalkeepersInMatch = [s.teams[teamA.name].goalkeeper, s.teams[teamB.name].goalkeeper].filter(Boolean);
    const uniquePlayersInMatch = new Set([...allPlayersInMatch, ...allGoalkeepersInMatch]);
    uniquePlayersInMatch.forEach(pName => {
      if (!playerStats[pName]) {
        playerStats[pName] = { goal: 0, assist: 0, defense: 0, save: 0, gamesPlayed: 0, wins: 0, draws: 0, losses: 0 };
      }
      playerStats[pName].gamesPlayed++;
      if (teamA.score === teamB.score) {
        playerStats[pName].draws++;
      } else {
        const winner = teamA.score > teamB.score ? teamA.name : teamB.name;
        if ((s.teams[winner].players.includes(pName) || s.teams[winner].goalkeeper === pName)) {
          playerStats[pName].wins++;
        } else {
          playerStats[pName].losses++;
        }
      }
    });
    const allTeamNames = ['RED', 'BLUE', 'YELLOW'];
    allTeamNames.forEach(name => {
      if (name === teamA_name || name === teamB_name) {
        teamStats[name].matchesPlayed++;
        teamStats[name].consecutivePlays++;
      } else {
        teamStats[name].consecutivePlays = 0;
      }
    });
    // --- (여기까지의 기존 로직은 모두 동일합니다) ---


    // ▼▼▼ [핵심 변경] 스프레드시트에 직접 기록하는 대신, 임시 저장 공간(matchHistory)에 데이터를 추가합니다. ▼▼▼
    const date = Utilities.formatDate(new Date(), SpreadsheetApp.getActive().getSpreadsheetTimeZone(), "yyyy-MM-dd");
    [s.match.teamA.name, s.match.teamB.name].forEach(teamName => {
      const teamData = s.teams[teamName];
      if (teamData.players.length > 0 || teamData.goalkeeper) {
        // matchHistory 배열에 경기 결과 객체를 추가
        s.sessionResults.matchHistory.push({
          date: date,
          matchNumber: count, // 현재 경기 번호
          teamName: teamName,
          goalkeeper: teamData.goalkeeper || '',
          players: teamData.players
        });
        Logger.log(`메모리에 경기 기록 저장 완료: ${teamName} - 경기 #${count}`);
      }
    });
    // ▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲

    s.match.count++; // 다음 경기를 위해 경기 수 증가
    s.match.timerRunning = false;

    // --- (여기부터) 다음 경기 자동 설정 로직은 변경 없이 그대로 유지됩니다 ---
    const currentPlayingTeams = [teamA_name, teamB_name];
    const waitingTeam = allTeamNames.find(name => !currentPlayingTeams.includes(name));
    let consecutivePlayedTeam = null;
    if (teamStats[teamA_name].consecutivePlays >= 3) {
      consecutivePlayedTeam = teamA_name;
    } else if (teamStats[teamB_name].consecutivePlays >= 3) {
      consecutivePlayedTeam = teamB_name;
    }
    if (consecutivePlayedTeam) {
      s.currentScreen = 'screen-match-controller';
      s.match.nextMatchSuggestion = {
        type: 'consecutive',
        team: consecutivePlayedTeam,
        suggestedTeams: allTeamNames.filter(t => t !== consecutivePlayedTeam)
      };
    } else if (teamA.score === teamB.score) {
      s.currentScreen = 'screen-match-controller';
      s.match.nextMatchSuggestion = {
        type: 'draw',
        drawingTeams: [teamA_name, teamB_name],
        waitingTeam: waitingTeam
      };
    } else {
      const winner = teamA.score > teamB.score ? teamA_name : teamB_name;
      const nextPlayingTeams = [winner, waitingTeam].filter(Boolean);
      if (nextPlayingTeams.length < 2) {
        s.currentScreen = 'screen-match-select';
      } else {
        s.match.playingTeams = nextPlayingTeams;
        s.match.teamA = { name: nextPlayingTeams[0], score: 0 };
        s.match.teamB = { name: nextPlayingTeams[1], score: 0 };
        s.match.timeline = [];
        s.match.seconds = s.match.selectedDuration;
        s.match.timerRunning = false;
        s.currentScreen = 'screen-match-controller';
      }
    }
    // --- (여기까지 다음 경기 자동 설정 로직은 동일합니다) ---
   
    saveAppState(s);
    return s;
  });
}


// 타이머 상태를 저장하는 함수입니다. (남은 시간 업데이트 기능 추가)
function toggleTimerState(running, seconds) { // 👈 1. seconds 파라미터가 추가되었습니다.
  return safeExecute(() => {
    const state = getAppState(); // 현재 앱 상태를 가져옵니다.
    state.match.timerRunning = running; // 타이머 실행 상태 업데이트
   
    // 👇 2. 이 if 문이 새로 추가되었습니다.
    // seconds 값이 유효한 숫자로 전달된 경우에만 업데이트합니다.
    if (typeof seconds === 'number' && !isNaN(seconds)) {
        state.match.seconds = seconds;
    }


    saveAppState(state); // 변경된 상태 저장
    return state; // 업데이트된 상태를 반환합니다.
  });
}
// [신규] 특정 팀의 골키퍼를 지정하는 함수입니다.
// teamName: 키퍼를 지정할 팀의 이름 (RED, BLUE, YELLOW)
// goalkeeperName: 키퍼로 지정할 선수의 이름 (어떤 팀 소속이든 가능)
function setGoalkeeper(teamName, goalkeeperName) {
  return safeExecute(() => {
    const state = getAppState(); // 현재 앱 상태를 가져옵니다.
   
    // [오류 수정] teamName이 유효한지 확인
    if (!state.teams[teamName]) {
      Logger.log(`오류: 존재하지 않는 팀 이름입니다: ${teamName}`);
      throw new Error(`존재하지 않는 팀 이름입니다: ${teamName}`);
    }


    // 지정할 선수가 참석자 목록에 있는지 확인 (필수는 아니지만, 에러 방지)
    if (goalkeeperName && !state.attendingPlayerNames.includes(goalkeeperName)) {
      Logger.log(`경고: ${goalkeeperName} 선수는 참석자 목록에 없습니다. 키퍼로 지정합니다.`);
      // 참석자 목록에 없어도 키퍼로 지정은 가능하게 하되, 경고 로그 남김
      // 필요시 throw new Error("참석자 목록에 없는 선수는 키퍼로 지정할 수 없습니다.") 로 변경 가능
    }


    // 해당 팀의 골키퍼를 지정합니다.
    state.teams[teamName].goalkeeper = goalkeeperName;
    Logger.log(`${teamName} 팀의 키퍼가 ${goalkeeperName || '미지정'} (으)로 지정되었습니다.`);


    saveAppState(state); // 변경된 상태를 저장합니다.
    return state; // 업데이트된 상태를 반환합니다.
  });
}


// [수정된 substitutePlayer 함수]
function substitutePlayer(teamName, playerOutName, playerInName) {
    return safeExecute(() => {
        const state = getAppState();
        const teamPlayers = state.teams[teamName].players;
        const playerOutIndex = teamPlayers.indexOf(playerOutName);
        if (playerOutIndex === -1) {
            Logger.log(`오류: ${playerOutName} 선수는 ${teamName} 팀의 필드 플레이어에 없습니다.`);
            throw new Error(`${playerOutName} 선수는 ${teamName} 팀의 필드 플레이어에 없습니다.`);
        }


        if (playerInName) {
            // 교체 투입할 선수가 다른 팀에 있는지 확인
            const allTeamNames = ['RED', 'BLUE', 'YELLOW'];
            let otherTeamName = null;
            let otherTeamPlayerIndex = -1;
            let isGoalkeeper = false;


            allTeamNames.forEach(tName => {
                if (tName !== teamName) {
                    // 필드 플레이어에서 찾기
                    const index = state.teams[tName].players.indexOf(playerInName);
                    if (index !== -1) {
                        otherTeamName = tName;
                        otherTeamPlayerIndex = index;
                    }
                    // 골키퍼에서 찾기
                    if (state.teams[tName].goalkeeper === playerInName) {
                        otherTeamName = tName;
                        isGoalkeeper = true;
                    }
                }
            });


            // 교체 투입할 선수가 다른 팀에 있다면,
            if (otherTeamName) {
                // 기존 선수와 교체
                if (isGoalkeeper) {
                    // 교체 투입 선수가 키퍼일 경우
                    state.teams[otherTeamName].goalkeeper = playerOutName;
                } else {
                    // 교체 투입 선수가 필드 플레이어일 경우
                    state.teams[otherTeamName].players[otherTeamPlayerIndex] = playerOutName;
                }
                Logger.log(`${otherTeamName} 팀의 ${playerInName} 선수가 ${playerOutName} 선수로 교체되었습니다.`);
            } else {
                // 교체 투입 선수가 대기 중인 선수일 경우
                const waitingPlayerIndex = state.attendingPlayerNames.indexOf(playerInName);
                if (waitingPlayerIndex !== -1) {
                    state.attendingPlayerNames.splice(waitingPlayerIndex, 1);
                }
                state.attendingPlayerNames.push(playerOutName);
                Logger.log(`${playerInName} 선수가 대기 선수에서 ${teamName} 팀으로 이동했습니다.`);
            }


            // 기존 팀 선수 교체
            teamPlayers[playerOutIndex] = playerInName;


            Logger.log(`${teamName} 팀에서 ${playerOutName} 선수가 ${playerInName} 선수로 교체되었습니다.`);
        } else {
            // 들어올 선수가 null인 경우 (단순히 선수 제거)
            teamPlayers.splice(playerOutIndex, 1);
            Logger.log(`${teamName} 팀에서 ${playerOutName} 선수가 제거되었습니다.`);
        }


        saveAppState(state);
        return state;
    });
}


// [신규] 무승부 시 다음 경기를 진행할 팀을 선택하는 함수
function selectNextPlayingTeam(selectedTeamName) {
  return safeExecute(() => {
    const s = getAppState();
    const { teamA, teamB } = s.match;
    const allTeamNames = ['RED', 'BLUE', 'YELLOW'];
    const waitingTeam = allTeamNames.find(name => name !== teamA.name && name !== teamB.name);


    // [오류 수정] selectedTeamName이 유효한지 확인
    if (!allTeamNames.includes(selectedTeamName)) {
      Logger.log(`오류: 유효하지 않은 팀 이름입니다: ${selectedTeamName}`);
      throw new Error("유효하지 않은 팀 이름입니다.");
    }
   
    const nextPlayingTeams = [selectedTeamName, waitingTeam].filter(Boolean);


    if (nextPlayingTeams.length < 2) {
      s.currentScreen = 'screen-match-select'; // 팀이 부족하면 경기 선택 화면으로
      Logger.log("다음 경기 진행할 팀이 부족하여 경기 선택 화면으로 이동.");
    } else {
      s.match.playingTeams = nextPlayingTeams;
      s.match.teamA = { name: nextPlayingTeams[0], score: 0 };
      s.match.teamB = { name: nextPlayingTeams[1], score: 0 };
      s.match.timeline = []; // 타임라인 초기화
      s.match.seconds = s.match.selectedDuration; // 시간 초기화
      s.match.timerRunning = false; // 타이머 정지
      s.currentScreen = 'screen-match-controller';
      Logger.log(`무승부 후 다음 경기 설정: ${nextPlayingTeams[0]} vs ${nextPlayingTeams[1]}`);
    }
    s.match.nextMatchSuggestion = null; // 제안 초기화
    saveAppState(s);
    return s;
  });
}


// [신규] 3경기 연속 경기 후 다음 경기 진행 여부 확인 함수
function confirmNextMatch(confirmProceed) {
  return safeExecute(() => {
    const s = getAppState();
    // [오류 수정] s.match.nextMatchSuggestion이 유효한지 확인
    if (!s.match.nextMatchSuggestion || !s.match.nextMatchSuggestion.team) {
      Logger.log("오류: confirmNextMatch 함수 호출 시 다음 경기 제안 정보가 유효하지 않습니다.");
      throw new Error("다음 경기 제안 정보를 찾을 수 없습니다.");
    }


    const allTeamNames = ['RED', 'BLUE', 'YELLOW'];
    const consecutivePlayedTeam = s.match.nextMatchSuggestion.team; // 3연속 뛴 팀
   
    // 3연속 뛴 팀을 제외한 나머지 두 팀을 찾음
    const suggestedNextTeams = allTeamNames.filter(name => name !== consecutivePlayedTeam);


    if (confirmProceed) { // '예'를 선택한 경우 (나머지 두 팀이 경기)
      if (suggestedNextTeams.length < 2) { // 혹시 모를 경우 (팀이 2개 이하일 때)
        s.currentScreen = 'screen-match-select';
        Logger.log("3연속 경기 후 강제 설정할 팀이 부족하여 경기 선택 화면으로 이동.");
      } else {
        s.match.playingTeams = suggestedNextTeams;
        s.match.teamA = { name: suggestedNextTeams[0], score: 0 };
        s.match.teamB = { name: suggestedNextTeams[1], score: 0 };
        s.match.timeline = []; // 타임라인 초기화
        s.match.seconds = s.match.selectedDuration; // 시간 초기화
        s.match.timerRunning = false; // 타이머 정지
        s.currentScreen = 'screen-match-controller';
        Logger.log(`3연속 경기 후 다음 경기 강제 설정: ${suggestedNextTeams[0]} vs ${suggestedNextTeams[1]}`);
      }
    } else { // '아니오'를 선택한 경우 (경기 선택 화면으로 이동)
      s.currentScreen = 'screen-match-select';
      Logger.log("3연속 경기 후 사용자 선택에 따라 경기 선택 화면으로 이동.");
    }
    s.match.nextMatchSuggestion = null; // 제안 초기화
    saveAppState(s);
    return s;
  });
}


// [신규] 세션 종료 시 최종 결과 계산 및 요약 화면으로 이동하는 함수
function finishSessionToSummary() {
  return safeExecute(() => {
    const s = getAppState();
    const playerStats = s.sessionStats.playerStats;
    // masterPlayers와 playerArchiveStats는 이제 사용되지 않지만, 향후 기능을 위해 남겨둡니다.
    const masterPlayers = getMasterPlayersFromSheet(); 
    const playerArchiveStats = getPlayerStatsFromArchive();

    // MVP, 최우수 수비수, 최우수 골키퍼 선정
    let mvp = null;
    let maxMvPScore = -1;
    let bestDefender = null;
    let maxDefense = -1;
    let bestGoalkeeper = null;
    let maxSave = -1;

    Object.keys(playerStats).forEach(pName => {
      const stats = playerStats[pName];
      const mvpScore = (stats.goal * 2) + (stats.assist * 2) + (stats.defense * 1) + (stats.save * 1);
     
      // MVP 선정
      if (mvpScore > maxMvPScore) {
        maxMvPScore = mvpScore;
        mvp = pName;
      }
      
      // ▼▼▼ [핵심 수정] 역할(Role) 구분 없이, 단순히 수비 스탯이 가장 높은 선수를 선정합니다. ▼▼▼
      if (stats.defense > maxDefense) {
        maxDefense = stats.defense;
        bestDefender = pName;
      }
      // ▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲
     
      // 최우수 골키퍼 (선방 기록이 가장 높은 선수)
      if (stats.save > maxSave) {
        maxSave = stats.save;
        bestGoalkeeper = pName;
      }
    });

    // 유의미한 기록이 있을 때만 수상자를 선정합니다.
    if (maxMvPScore === 0) mvp = null;
    if (maxDefense === 0) bestDefender = null;
    if (maxSave === 0) bestGoalkeeper = null;
    
    // sessionResults 객체에 다른 정보가 있을 수 있으므로, 기존 정보를 유지하며 수상자 정보만 업데이트합니다.
    s.sessionResults = {
      ...s.sessionResults, // 기존 sessionResults 정보 (예: matchHistory) 유지
      mvp: mvp,
      bestDefender: bestDefender,
      bestGoalkeeper: bestGoalkeeper
    };
    
    s.currentScreen = 'screen-session-summary';
    saveAppState(s);
    return s;
  });
}

// =================================================================
// 파일: Code.gs | 1.3 | [배치 쓰기 적용] 함수 수정: updateAndArchiveSession
// =================================================================
function updateAndArchiveSession() {
  return safeExecute(() => {
    const state = getAppState();
    const date = Utilities.formatDate(new Date(), SpreadsheetApp.getActive().getSpreadsheetTimeZone(), "yyyy-MM-dd");
   
    const archiveSheet = getSheet(CONFIG.PLAYER_ARCHIVE_SHEET);
    const rowsToAdd = Object.keys(state.sessionStats.playerStats)
      .filter(pName => state.sessionStats.playerStats[pName].gamesPlayed > 0)
      .map(pName => {
        const stat = state.sessionStats.playerStats[pName];
        return [date, pName, stat.gamesPlayed, stat.wins, stat.draws, stat.losses, stat.goal, stat.assist, stat.defense, stat.save];
      });
    if(rowsToAdd.length > 0) {
    // K열(11번째 열)까지만 체크하여 실제 데이터가 있는 마지막 행 찾기
    let lastDataRow = 1; // 헤더 행
    const dataRange = archiveSheet.getRange(1, 1, archiveSheet.getLastRow(), 10).getValues();
    
    for(let i = dataRange.length - 1; i >= 1; i--) {
        if(dataRange[i][1]) { // B열(선수명)에 값이 있으면
            lastDataRow = i + 1;
            break;
        }
    }
    
    // 실제 데이터 다음 행부터 추가
    archiveSheet.getRange(lastDataRow + 1, 1, rowsToAdd.length, rowsToAdd[0].length).setValues(rowsToAdd);
}
    
    const pastTeamsSheet = getSheet(CONFIG.PAST_TEAMS_SHEET);
    const teamRowsToAdd = state.sessionResults.matchHistory.map(match => {
        const players = match.players.slice(0, 7);
        while(players.length < 7) {
            players.push('');
        }
        return [match.date, match.matchNumber, match.teamName, match.goalkeeper, ...players];
    });

    if (teamRowsToAdd.length > 0) {
        if(pastTeamsSheet.getRange(1,1).getValue() === "") {
            pastTeamsSheet.appendRow(["경기일", "경기번호", "팀명", "키퍼", "선수1", "선수2", "선수3", "선수4", "선수5", "선수6", "선수7"]);
        }
        pastTeamsSheet.getRange(pastTeamsSheet.getLastRow() + 1, 1, teamRowsToAdd.length, teamRowsToAdd[0].length).setValues(teamRowsToAdd);
    }
    
    SpreadsheetApp.flush();
    
    // 앱 상태 시트도 초기화
    const stateSheet = getSheet(CONFIG.APP_STATE_SHEET);
    stateSheet.clear();
    
    return getAppState();
  });
}

// [신규] 세션 내 선수 개인 스탯을 업데이트하는 함수 (기록 수정 화면에서 사용)
function updateSessionPlayerStats(playerName, statType, newValue) {
  return safeExecute(() => {
    const s = getAppState();
    if (s.sessionStats.playerStats[playerName]) {
      const oldValue = s.sessionStats.playerStats[playerName][statType];
      s.sessionStats.playerStats[playerName][statType] = Number(newValue) || 0;


      // 득점/실점 연동 로직
      if (statType === 'goal') {
        const diff = (Number(newValue) || 0) - oldValue;
        // 이 로직은 해당 선수가 특정 팀에 속했다는 가정이 필요 (현재는 이 정보가 세션 스탯에 직접 없음)
        // 가장 최근의 경기에서 해당 선수가 속했던 팀의 득실차를 추적해야 하지만,
        // 여기서는 해당 선수가 어느 팀에 속했었는지 직접적인 연결이 없으므로,
        // 세션 내 팀별 득실점은 '경기 종료' 시점에만 업데이트하는 것이 현실적입니다.
        // 따라서 기록 수정 화면에서 '골' 스탯을 직접 수정하는 경우, 팀의 득실점은 자동 업데이트되지 않습니다.
        // 이는 UI/UX 설계 시 사용자가 이해하도록 안내해야 할 부분입니다.
        // (현재는 updateSessionPlayerStats에서 teamNameForGoalUpdate를 받지 않으므로 연동 로직은 비활성화)
      }
     
    }
    saveAppState(s);
    return s;
  });
}


// 선수 능력치를 계산하는 함수
function getPlayerPower(player, criteria) {
  switch (criteria) {
    case 'sheet_only':
      return player.att + player.def; // 임의스탯 (공격+수비)
    case 'ccpBased':
      return player.ccp || 0;
    case 'mpBased':
      return player.mp || 0;
    case 'mpPerGameBased':
      return player.mpPerGame || 0;
    case 'winRateBased':
      return player.winRate || 0;
    case 'mixed_ccp':
      return ((player.att + player.def) + (player.ccp || 0)) / 2; // 50:50 혼합
    default:
      return player.att + player.def;
  }
}

// 1. 스네이크 방식 (기존)
function allocateSnakeMethod(players, teams, teamNames) {
    players.sort((a, b) => b.power - a.power);
    let currentTeamIndex = 0;
    let direction = 1;
    
    players.forEach(player => {
        teams[teamNames[currentTeamIndex]].players.push(player);
        currentTeamIndex += direction;
        if (currentTeamIndex >= teamNames.length || currentTeamIndex < 0) {
            direction *= -1;
            currentTeamIndex += direction;
        }
    });
}




/**
 * 3팀 고정 초간단 배분
 * - 18명: 6명씩, 21명: 7명씩
 * - 그 외: 팀 간 인원 차이 최대 1
 * - 로직: 높은 파워 순으로 정렬 → 아직 덜 찬 팀 중 합계 파워가 낮은 팀에 배치
 * - 필요 시 enableSwap=true로 1회만 빠른 스왑(개선되면 적용)
 *
 * 사용:
 * const teamNames = ['Blue','Red','Yellow'];
 * const result = allocateTeamsSimple(players, teamNames, true); // true=1회 스왑
 */
function allocateTeamsSimple(players, teamNames, enableSwap) {
  if (!Array.isArray(teamNames) || teamNames.length !== 3) {
    throw new Error('teamNames는 정확히 3개여야 합니다.');
  }
  if (!Array.isArray(players) || players.length === 0) {
    throw new Error('players가 비어 있습니다.');
  }

  // 1) 팀별 목표 인원(쿼터) 계산
  const quotas = computeQuotasFor3(players.length); // 예: [6,6,6] 또는 [7,7,7] 등

  // 2) 초기 상태
  const sorted = players.map(p => ({ ...p, power: Number(p.power) || 0 }))
                        .sort((a, b) => b.power - a.power); // 높은 파워 우선
  const teamState = teamNames.map((name, i) => ({
    name, players: [], sumPower: 0, target: quotas[i]
  }));

  // 3) 간단 그리디 배치
  for (const pl of sorted) {
    // 아직 인원 미달인 팀 중 합계 파워가 낮은 팀
    const candidate = teamState
      .filter(t => t.players.length < t.target)
      .sort((a, b) => {
        if (a.sumPower !== b.sumPower) return a.sumPower - b.sumPower;     // 파워 낮은 팀 우선
        const ar = a.target - a.players.length, br = b.target - b.players.length;
        if (ar !== br) return br - ar;                                      // 남은 슬롯 많은 팀
        return String(a.name).localeCompare(String(b.name));                // 안정적 타이브레이커
      })[0];

    if (!candidate) throw new Error('배치할 팀이 없습니다(쿼터 계산 확인).');
    candidate.players.push(pl);
    candidate.sumPower += pl.power;
  }

  // 4) 선택: 1회만 아주 간단한 스왑으로 균형 개선 시도
  if (enableSwap) {
    quickOneSwap(teamState);
  }

  // 5) 결과 정리
  const out = {};
  for (const t of teamState) {
    out[t.name] = { players: t.players, sumPower: t.sumPower, size: t.players.length };
  }
  return out;
}

/**
 * 18명→[6,6,6], 21명→[7,7,7], 그 외는 차이 ≤ 1 되도록 분배
 */
function computeQuotasFor3(total) {
  if (total === 18) return [6, 6, 6];
  if (total === 21) return [7, 7, 7];
  const base = Math.floor(total / 3);
  const rem = total % 3; // 0,1,2
  const q = [base, base, base];
  for (let i = 0; i < rem; i++) q[i] += 1; // 앞 팀부터 +1
  // 안전 확인: 차이 1 초과 금지
  const maxQ = Math.max(...q), minQ = Math.min(...q);
  if (maxQ - minQ > 1) throw new Error('쿼터 계산 오류: 팀 간 인원 차이가 1을 초과합니다.');
  return q;
}

/**
 * 아주 빠른 1회 스왑 시도(표준편차가 줄어드는 경우에만 교환)
 * - 최강팀과 최약팀 사이에서만 1쌍 교환
 */
function quickOneSwap(teamState) {
  const sums = () => teamState.map(t => t.sumPower);
  const baseStd = std(sums());
  // 최약/최강 팀
  const ordered = [...teamState].sort((a, b) => a.sumPower - b.sumPower);
  const weak = ordered[0];
  const strong = ordered[ordered.length - 1];
  if (!weak.players.length || !strong.players.length) return;

  // 후보를 많이 돌지 않고, 강팀의 약한 쪽 vs 약팀의 강한 쪽 위주로만 간단 탐색
  const strongSorted = [...strong.players].sort((a, b) => a.power - b.power); // 약한→강한
  const weakSorted   = [...weak.players].sort((a, b) => b.power - a.power);   // 강한→약한
  const topK = Math.min(3, strongSorted.length, weakSorted.length);

  let best = null, bestStd = baseStd;
  for (let i = 0; i < topK; i++) {
    const a = strongSorted[i]; // 강팀의 상대적 약한 선수
    const b = weakSorted[i];   // 약팀의 상대적 강한 선수
    if (!a || !b) continue;

    const strongNew = strong.sumPower - a.power + b.power;
    const weakNew   = weak.sumPower   - b.power + a.power;

    const newSums = teamState.map(t => {
      if (t === strong) return strongNew;
      if (t === weak)   return weakNew;
      return t.sumPower;
    });
    const newStd = std(newSums);
    if (newStd + 1e-9 < bestStd) {
      bestStd = newStd;
      best = { a, b };
    }
  }

  if (best) {
    const ai = strong.players.indexOf(best.a);
    const bi = weak.players.indexOf(best.b);
    if (ai >= 0 && bi >= 0) {
      strong.players[ai] = best.b;
      weak.players[bi]   = best.a;
      strong.sumPower = strong.sumPower - best.a.power + best.b.power;
      weak.sumPower   = weak.sumPower   - best.b.power + best.a.power;
    }
  }
}

/**
 * 표준편차(간단 버전)
 */
function std(arr) {
  if (!arr.length) return 0;
  const m = arr.reduce((s, v) => s + v, 0) / arr.length;
  const v = arr.reduce((s, v) => s + (v - m) * (v - m), 0) / arr.length;
  return Math.sqrt(v);
}


function allocateBalanced(players, teams, teamNames) {
    players.sort((a, b) => b.power - a.power);
    
    // 탐욕 알고리즘으로 초기 배분
    players.forEach(player => {
        const teamPowers = teamNames.map(name => ({
            name: name,
            power: teams[name].players.reduce((sum, p) => sum + p.power, 0),
            count: teams[name].players.length
        })).sort((a, b) => {
            if (a.count !== b.count) return a.count - b.count; // 인원 우선
            return a.power - b.power; // 능력치 차순
        });
        
        teams[teamPowers[0].name].players.push(player);
    });
    
    // 간단한 균형 조정 (5회)
    for (let i = 0; i < 5; i++) {
        const teamPowers = teamNames.map(name => ({
            name: name,
            power: teams[name].players.reduce((sum, p) => sum + p.power, 0),
            players: teams[name].players
        })).sort((a, b) => a.power - b.power);
        
        const weakest = teamPowers[0];
        const strongest = teamPowers[2];
        const gap = strongest.power - weakest.power;
        
        if (gap <= 20) break; // 충분히 균형잡힘
        
        // 간단한 교환
        if (strongest.players.length > 0 && weakest.players.length > 0) {
            const weakInStrong = strongest.players.reduce((prev, curr) => 
                prev.power < curr.power ? prev : curr
            );
            const strongInWeak = weakest.players.reduce((prev, curr) => 
                prev.power > curr.power ? prev : curr
            );
            
            if (weakInStrong.power < strongInWeak.power) {
                const strongIdx = strongest.players.indexOf(weakInStrong);
                const weakIdx = weakest.players.indexOf(strongInWeak);
                
                strongest.players[strongIdx] = strongInWeak;
                weakest.players[weakIdx] = weakInStrong;
            }
        }
    }
}

// 2. CCP 순위기반용 새 함수 추가 (CCP 1점 이내)
function allocateCcpBased(players, teams, teamNames) {
   console.log("CCP 기반 배분 시작");
    console.log("선수별 CCP:", players.map(p => `${p.name}:${p.power}`));
    players.sort((a, b) => b.power - a.power);
    
    // 초기 균등 배분
    players.forEach((player, i) => {
        teams[teamNames[i % teamNames.length]].players.push(player);
    });
    
    // CCP 균형 조정 (최대 50회)
    for (let i = 0; i < 50; i++) {
        const teamStats = teamNames.map(name => ({
            name: name,
            avgCcp: teams[name].players.reduce((sum, p) => sum + p.power, 0) / teams[name].players.length,
            players: teams[name].players
        })).sort((a, b) => a.avgCcp - b.avgCcp);
        
        const weakest = teamStats[0];
        const strongest = teamStats[2];
        const ccpGap = strongest.avgCcp - weakest.avgCcp;
        
        if (ccpGap <= 1) break; // CCP 1점 이내면 종료
        
        // 선수 교환
        if (strongest.players.length > 0 && weakest.players.length > 0) {
            const weakInStrong = strongest.players.reduce((prev, curr) => 
                prev.power < curr.power ? prev : curr
            );
            const strongInWeak = weakest.players.reduce((prev, curr) => 
                prev.power > curr.power ? prev : curr
            );
            
            if (weakInStrong.power < strongInWeak.power) {
                const strongIdx = strongest.players.indexOf(weakInStrong);
                const weakIdx = weakest.players.indexOf(strongInWeak);
                
                strongest.players[strongIdx] = strongInWeak;
                weakest.players[weakIdx] = weakInStrong;
            } else {
                break;
            }
        }
    }
}


// 1. allocateMpBased 함수 교체 (현재 불균등 배분 문제)
function allocateMpBased(players, teams, teamNames) {
    players.sort((a, b) => b.power - a.power);
    
    players.forEach(player => {
        const teamPowers = teamNames.map(name => ({
            name: name,
            power: teams[name].players.reduce((sum, p) => sum + p.power, 0),
            count: teams[name].players.length
        })).sort((a, b) => {
            // ★ 인원수 우선 비교로 변경
            if (a.count !== b.count) return a.count - b.count; // 인원 적은 팀 우선
            return a.power - b.power; // 인원 같으면 약한 팀 우선
        });
        
        teams[teamPowers[0].name].players.push(player);
    });
}

// 2. allocateMpPerGameBased 함수 교체 (지그재그 방식 개선)
function allocateMpPerGameBased(players, teams, teamNames) {
    players.sort((a, b) => b.power - a.power);
    
    // 개선된 지그재그: 더 균형잡힌 패턴
    let assignments = [];
    let teamIndex = 0;
    let direction = 1;
    
    players.forEach(player => {
        assignments.push({ player, teamIndex });
        
        if (direction === 1) {
            teamIndex++;
            if (teamIndex >= teamNames.length) {
                teamIndex = teamNames.length - 1;
                direction = -1;
            }
        } else {
            teamIndex--;
            if (teamIndex < 0) {
                teamIndex = 0;
                direction = 1;
            }
        }
    });
    
    // 배분 실행
    assignments.forEach(assignment => {
        teams[teamNames[assignment.teamIndex]].players.push(assignment.player);
    });
}

// 1. allocateWinRateBased 함수 수정 (승률 2% 이내, CCP 3점 이내)
function allocateWinRateBased(players, teams, teamNames) {
    players.sort((a, b) => b.power - a.power);
    
    // 초기 균등 배분
    players.forEach((player, i) => {
        teams[teamNames[i % teamNames.length]].players.push(player);
    });
    
    // 승률 균형 조정 (최대 50회)
    for (let i = 0; i < 50; i++) {
        const teamStats = teamNames.map(name => ({
            name: name,
            avgWinRate: teams[name].players.reduce((sum, p) => sum + p.power, 0) / teams[name].players.length,
            players: teams[name].players
        })).sort((a, b) => a.avgWinRate - b.avgWinRate);
        
        const weakest = teamStats[0];
        const strongest = teamStats[2];
        const winRateGap = strongest.avgWinRate - weakest.avgWinRate;
        
        if (winRateGap <= 2) break; // 승률 2% 이내면 종료
        
        // 선수 교환
        if (strongest.players.length > 0 && weakest.players.length > 0) {
            const weakInStrong = strongest.players.reduce((prev, curr) => 
                prev.power < curr.power ? prev : curr
            );
            const strongInWeak = weakest.players.reduce((prev, curr) => 
                prev.power > curr.power ? prev : curr
            );
            
            if (weakInStrong.power < strongInWeak.power) {
                const strongIdx = strongest.players.indexOf(weakInStrong);
                const weakIdx = weakest.players.indexOf(strongInWeak);
                
                strongest.players[strongIdx] = strongInWeak;
                weakest.players[weakIdx] = weakInStrong;
            } else {
                break;
            }
        }
    }
}

// 4. 새로운 균형 체크 함수 (디버깅용)
function checkTeamBalance(teams, teamNames) {
    const teamPowers = teamNames.map(name => ({
        name: name,
        power: teams[name].players.reduce((sum, p) => sum + p.power, 0),
        count: teams[name].players.length
    }));
    
    console.log('팀 균형 체크:');
    teamPowers.forEach(team => {
        console.log(`${team.name}: ${team.power.toFixed(1)} (${team.count}명)`);
    });
    
    const maxPower = Math.max(...teamPowers.map(t => t.power));
    const minPower = Math.min(...teamPowers.map(t => t.power));
    const gap = maxPower - minPower;
    
    console.log(`최대 능력치 차이: ${gap.toFixed(1)} ${gap <= 15 ? '(균형잡힌)' : '(불균형)'}`);
    
    return gap <= 15;
}

// 6. 완전 랜덤
function allocateRandom(players, teams, teamNames) {
    const shuffled = players.sort(() => 0.5 - Math.random());
    shuffled.forEach((player, i) => {
        teams[teamNames[i % teamNames.length]].players.push(player);
    });
}


// 주장/부주장 랜덤 설정
function assignCaptains(teams) {
    Object.keys(teams).forEach(teamName => {
        const playersInTeam = teams[teamName].players;
        if (playersInTeam.length > 0) {
            // 랜덤으로 주장 선정
            const randomCaptainIndex = Math.floor(Math.random() * playersInTeam.length);
            const captain = playersInTeam[randomCaptainIndex];
            teams[teamName].captain = captain.name;
            
            // 주장을 제외한 나머지 선수들
            const others = playersInTeam.filter((p, index) => index !== randomCaptainIndex);
            if (others.length > 0) {
                // 랜덤으로 부주장 선정
                const randomViceIndex = Math.floor(Math.random() * others.length);
                const viceCaptain = others[randomViceIndex];
                teams[teamName].viceCaptain = viceCaptain.name;
            } else {
                teams[teamName].viceCaptain = null;
            }
        } else {
            teams[teamName].captain = null;
            teams[teamName].viceCaptain = null;
        }
    });
}
