
const CONFIG = {
  STATS_SHEET: "ì„ ìˆ˜ë³„ëŠ¥ë ¥ì¹˜", // ì„ ìˆ˜ë“¤ì˜ ê¸°ë³¸ ëŠ¥ë ¥ì¹˜ (ê³µê²©, ìˆ˜ë¹„, í¬ì§€ì…˜)ê°€ ê¸°ë¡ëœ ì‹œíŠ¸ ì´ë¦„
  PLAYER_ARCHIVE_SHEET: "ê¸°ë¡ì‹¤_ê°œì¸ê¸°ë¡", // ê°œì¸ë³„ ê²½ê¸° ê¸°ë¡ì´ ëˆ„ì ë˜ëŠ” ì‹œíŠ¸ ì´ë¦„
  PAST_TEAMS_SHEET: "ì§€ë‚œ_íŒ€_êµ¬ì„±", // ê³¼ê±° ê²½ê¸°ì—ì„œ íŒ€ êµ¬ì„±ì´ ê¸°ë¡ë  ì‹œíŠ¸ ì´ë¦„
  APP_STATE_SHEET: "ì•±_ìƒíƒœ_ì €ì¥" 
};


let batchSaveTimer = null;
let lastBatchSave = 0;

// --- ì›¹ ì•± ì§„ì…ì  ---
// ì›¹ ì•±ì´ ì²˜ìŒ ë¡œë“œë  ë•Œ ì‹¤í–‰ë˜ëŠ” í•¨ìˆ˜ì…ë‹ˆë‹¤.
function doGet(e) {
  // 'index' HTML íŒŒì¼ì„ ì›¹ í˜ì´ì§€ë¡œ ë³€í™˜í•˜ì—¬ ë°˜í™˜í•©ë‹ˆë‹¤.
  // í˜ì´ì§€ ì œëª©ì„ 'í’‹ì‚´ ë§¤ë‹ˆì € (ì—…ê·¸ë ˆì´ë“œ)'ë¡œ ì„¤ì •í•©ë‹ˆë‹¤.
  return HtmlService.createHtmlOutputFromFile('index').setTitle('JMFCí’‹ì‚´ ë§¤ë‹ˆì €');
}


// --- ì•ˆì „ ì‹¤í–‰ ë˜í¼ ---
// ì„œë²„ í•¨ìˆ˜ í˜¸ì¶œ ì‹œ ë™ì‹œì„± ë¬¸ì œë¥¼ ë°©ì§€í•˜ê³  ì˜¤ë¥˜ë¥¼ ì²˜ë¦¬í•˜ëŠ” ë˜í¼ í•¨ìˆ˜ì…ë‹ˆë‹¤.
function safeExecute(func, ...args) {
  const lock = LockService.getScriptLock(); // ìŠ¤í¬ë¦½íŠ¸ ì ê¸ˆ ê°ì²´ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.
  lock.waitLock(30000); // ë‹¤ë¥¸ ì‹¤í–‰ì´ ì™„ë£Œë  ë•Œê¹Œì§€ ìµœëŒ€ 30ì´ˆ ëŒ€ê¸°í•©ë‹ˆë‹¤.
  try {
    const result = func(...args); // ì „ë‹¬ëœ í•¨ìˆ˜ë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤.
    return { success: true, data: result }; // ì„±ê³µ ì‹œ ì„±ê³µ ìƒíƒœì™€ ê²°ê³¼ ë°ì´í„°ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
  } catch (e) {
    // ì˜¤ë¥˜ ë°œìƒ ì‹œ ì˜¤ë¥˜ ë©”ì‹œì§€ì™€ ìŠ¤íƒ íŠ¸ë ˆì´ìŠ¤ë¥¼ ê¸°ë¡í•©ë‹ˆë‹¤.
    Logger.log(`ì˜¤ë¥˜ ë°œìƒ: ${e.message}\n${e.stack}`);
    // ì‹¤íŒ¨ ì‹œ ì‹¤íŒ¨ ìƒíƒœì™€ ì˜¤ë¥˜ ë©”ì‹œì§€ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
    return { success: false, message: e.message };
  } finally {
    lock.releaseLock(); // ì‘ì—…ì´ ì™„ë£Œë˜ë©´ ì ê¸ˆì„ í•´ì œí•©ë‹ˆë‹¤.
  }
}


// --- ë°ì´í„° ì†ŒìŠ¤ ë° ìƒíƒœ ê´€ë¦¬ ---
// ì•±ì˜ ì´ˆê¸° ë°ì´í„°ë¥¼ ê°€ì ¸ì˜¤ëŠ” í•¨ìˆ˜ì…ë‹ˆë‹¤. (ì›¹ ì•± ë¡œë“œ ì‹œ í˜¸ì¶œ)
function getInitialData() {
  // ë§ˆìŠ¤í„° ì„ ìˆ˜ ëª©ë¡, í˜„ì¬ ì•± ìƒíƒœ, ì„ ìˆ˜ë³„ ëˆ„ì  ê¸°ë¡ì„ ê°€ì ¸ì™€ ë°˜í™˜í•©ë‹ˆë‹¤.
  return safeExecute(() => ({
    masterPlayers: getMasterPlayersFromSheet(), // ì„ ìˆ˜ë³„ ëŠ¥ë ¥ì¹˜ ì‹œíŠ¸ì—ì„œ ë§ˆìŠ¤í„° ì„ ìˆ˜ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
    appState: getAppState(), // ìºì‹œì—ì„œ í˜„ì¬ ì•± ìƒíƒœ ê°€ì ¸ì˜¤ê¸° (ì—†ìœ¼ë©´ ì´ˆê¸° ìƒíƒœ ìƒì„±)
    playerArchiveStats: getPlayerStatsFromArchive() // ì„ ìˆ˜ë³„ ëˆ„ì  ê¸°ë¡ ê°€ì ¸ì˜¤ê¸°
  }));
}


// 1. getMasterPlayersFromSheet ìµœì í™”
function getMasterPlayersFromSheet() {
  const sheet = getSheet(CONFIG.STATS_SHEET);
  if (sheet.getLastRow() < 2) return [];
  
  // â˜… í•„ìš”í•œ ì»¬ëŸ¼ë§Œ ì •í™•íˆ ì½ê¸° (20ê°œ â†’ 8ê°œ)
  const ranges = [
    sheet.getRange(2, 1, sheet.getLastRow() - 1, 4), // A-D (ì´ë¦„,í¬ì§€ì…˜,ê³µê²©,ìˆ˜ë¹„)
    sheet.getRange(2, 14, sheet.getLastRow() - 1, 1), // N (ìŠ¹ë¥ )  
    sheet.getRange(2, 15, sheet.getLastRow() - 1, 1), // O (CCP)
    sheet.getRange(2, 19, sheet.getLastRow() - 1, 1), // S (MP)
    sheet.getRange(2, 20, sheet.getLastRow() - 1, 1)  // T (MP/G)
  ];
  
  // í•œë²ˆì— ì½ê¸°
  const [basicData, winRateData, ccpData, mpData, mpPerGameData] = ranges.map(r => r.getValues());
  
  return basicData.map((row, i) => ({
    name: row[0],
    position: row[1], 
    att: Number(row[2]) || 5,
    def: Number(row[3]) || 5,
    winRate: Number(winRateData[i][0]) || 0,
    ccp: Number(ccpData[i][0]) || 0,
    mp: Number(mpData[i][0]) || 0,
    mpPerGame: Number(mpPerGameData[i][0]) || 0
  })).filter(p => p.name);
}


// =================================================================
// íŒŒì¼: Code.gs | 1.1 | í•¨ìˆ˜ ìˆ˜ì •: getAppState
// =================================================================
// ì•± ìƒíƒœë¥¼ ìŠ¤í”„ë ˆë“œì‹œíŠ¸ì—ì„œ ê°€ì ¸ì˜¤ê¸°
function getAppState() {
  const sheet = getSheet(CONFIG.APP_STATE_SHEET);
  
  // A1 ì…€ì—ì„œ JSON ë°ì´í„° ì½ê¸°
  const stateString = sheet.getRange('A1').getValue();
  
  if (stateString) {
    try {
      const parsedState = JSON.parse(stateString);
  
      parsedState.selectedDate = parsedState.selectedDate ||
      Utilities.formatDate(new Date(), SpreadsheetApp.getActive().getSpreadsheetTimeZone(), "yyyy-MM-dd");
      parsedState.match.selectedDuration = parsedState.match.selectedDuration || 600; // ê¸°ë³¸ 10ë¶„ (600ì´ˆ)
      parsedState.selectedField = parsedState.selectedField || 'A êµ¬ì¥'; // ì„ íƒëœ êµ¬ì¥ëª… ì´ˆê¸°í™”
       // ì›íŒ€ ë°ì´í„° ì €ì¥ì„ ìœ„í•œ í•„ë“œ ì¶”ê°€
      parsedState.originalTeams = parsedState.originalTeams || null;

      if (!parsedState.sessionStats.playerStats) parsedState.sessionStats.playerStats = {};
      parsedState.attendingPlayerNames.forEach(pName => {
        if (!parsedState.sessionStats.playerStats[pName]) {
          parsedState.sessionStats.playerStats[pName] = { goal: 0, assist: 0, defense: 0, save: 0, gamesPlayed: 0, wins: 0, draws: 0, losses: 0 };
        }
      });
      if (!parsedState.teams.RED.players && Array.isArray(parsedState.teams.RED)) parsedState.teams.RED = { players: parsedState.teams.RED, goalkeeper: null };
      if (!parsedState.teams.BLUE.players && Array.isArray(parsedState.teams.BLUE)) parsedState.teams.BLUE = { players: parsedState.teams.BLUE, goalkeeper: null };
      if (!parsedState.teams.YELLOW.players && Array.isArray(parsedState.teams.YELLOW)) parsedState.teams.YELLOW = { players: parsedState.teams.YELLOW, goalkeeper: null };
      parsedState.match.todayHeadToHead = parsedState.match.todayHeadToHead || {};
      
      // â–¼â–¼â–¼ [í•µì‹¬ ìˆ˜ì •] matchHistory ë°°ì—´ì„ ì¶”ê°€í•˜ê³  ì´ˆê¸°í™”í•©ë‹ˆë‹¤. â–¼â–¼â–¼
      parsedState.sessionResults = parsedState.sessionResults || { matchHistory: [] }; 
      if (!parsedState.sessionResults.matchHistory) {
        parsedState.sessionResults.matchHistory = [];
      }
      // â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²
      
      parsedState.match.nextMatchSuggestion = parsedState.match.nextMatchSuggestion || null;

     return parsedState;
    } catch(e) {
      Logger.log("ì†ìƒëœ ì €ì¥ ë°ì´í„°ë¥¼ ì‚­ì œí•˜ê³  ìƒˆ ìƒíƒœë¡œ ì‹œì‘í•©ë‹ˆë‹¤.");
      sheet.clear();
    }
  }

 // ì´ˆê¸° ìƒíƒœ ìƒì„±
  const teamStatTemplate = { wins: 0, draws: 0, losses: 0, consecutiveMatches: 0, goalsFor: 0, goalsAgainst: 0, matchesPlayed: 0, consecutivePlays: 0 };
  const initialState = {
    currentScreen: 'screen-attendance',
    selectedDate: Utilities.formatDate(new Date(), SpreadsheetApp.getActive().getSpreadsheetTimeZone(), "yyyy-MM-dd"),
    selectedField: 'A êµ¬ì¥',
    attendingPlayerNames: [],
    teams: {
      RED: { players: [], goalkeeper: null },
      BLUE: { players: [], goalkeeper: null },
      YELLOW: { players: [], goalkeeper: null }
    },
    originalTeams: null, // ì›íŒ€ ë°ì´í„° ì €ì¥ìš©
    match: {
      count: 1,
      playingTeams: [],
      teamA: { name: '', score: 0 },
      teamB: { name: '', score: 0 },
      timeline: [],
      seconds: 600,
      timerRunning: false,
      selectedDuration: 600,
      todayHeadToHead: {}
    },
    sessionStats: {
      playerStats: {},
      teamStats: { RED: {...teamStatTemplate}, BLUE: {...teamStatTemplate}, YELLOW: {...teamStatTemplate} }
    },
    sessionResults: { 
      matchHistory: [] 
    }
  };
  
  saveAppState(initialState);
  return initialState;
}

// ì•± ìƒíƒœë¥¼ ìŠ¤í”„ë ˆë“œì‹œíŠ¸ì— ì €ì¥
function saveAppState(state) {
  const sheet = getSheet(CONFIG.APP_STATE_SHEET);
  const jsonString = JSON.stringify(state);
  
  // A1 ì…€ì— JSON ì €ì¥
  sheet.getRange('A1').setValue(jsonString);
  
  // B1 ì…€ì— ìµœì¢… ì €ì¥ ì‹œê°„ ê¸°ë¡ (ë””ë²„ê¹…ìš©)
  sheet.getRange('B1').setValue(new Date().toLocaleString('ko-KR'));
}


// ì„¸ì…˜ ì´ˆê¸°í™” (ì‹œíŠ¸ ë°ì´í„° ì‚­ì œ)
function resetSession() {
  return safeExecute(() => {
    const sheet = getSheet(CONFIG.APP_STATE_SHEET);
    sheet.clear(); // ì‹œíŠ¸ ë‚´ìš© ì‚­ì œ
    return getAppState(); // ìƒˆë¡œìš´ ì´ˆê¸° ìƒíƒœ ë°˜í™˜
  });
}

// ì›íŒ€ ì €ì¥ í•¨ìˆ˜ (ìƒˆë¡œ ì¶”ê°€)
function saveOriginalTeams() {
  return safeExecute(() => {
    const state = getAppState();
    
    // ì›íŒ€ì´ ì•„ì§ ì €ì¥ë˜ì§€ ì•Šì•˜ë‹¤ë©´ í˜„ì¬ íŒ€ì„ ì›íŒ€ìœ¼ë¡œ ì €ì¥
    if (!state.originalTeams) {
      state.originalTeams = JSON.parse(JSON.stringify(state.teams));
      Logger.log("ì›íŒ€ êµ¬ì„±ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.");
    }
    
    saveAppState(state);
    return state;
  });
}

// ì›íŒ€ ë³µêµ¬ í•¨ìˆ˜ (ìƒˆë¡œ ì¶”ê°€)
function restoreOriginalTeams() {
  return safeExecute(() => {
    const state = getAppState();
    
    if (state.originalTeams) {
      state.teams = JSON.parse(JSON.stringify(state.originalTeams));
      Logger.log("ì›íŒ€ êµ¬ì„±ìœ¼ë¡œ ë³µêµ¬ë˜ì—ˆìŠµë‹ˆë‹¤.");
      saveAppState(state);
    }
    
    return state;
  });
}

// í˜„ì¬ í™”ë©´ì„ ë³€ê²½í•˜ê³  ì•± ìƒíƒœë¥¼ ì €ì¥í•˜ëŠ” í•¨ìˆ˜ì…ë‹ˆë‹¤.
function changeScreen(id) {
  return safeExecute(() => {
    const s = getAppState(); // í˜„ì¬ ì•± ìƒíƒœë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.
    s.currentScreen = id; // í™”ë©´ IDë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.
    saveAppState(s); // ë³€ê²½ëœ ìƒíƒœë¥¼ ì €ì¥í•©ë‹ˆë‹¤.
    return s; // ì—…ë°ì´íŠ¸ëœ ìƒíƒœë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
  });
}


// ìŠ¤í”„ë ˆë“œì‹œíŠ¸ì—ì„œ íŠ¹ì • ì‹œíŠ¸ë¥¼ ê°€ì ¸ì˜¤ê±°ë‚˜ ì—†ìœ¼ë©´ ìƒˆë¡œ ìƒì„±í•˜ëŠ” í•¨ìˆ˜ì…ë‹ˆë‹¤.
function getSheet(sheetName) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  return ss.getSheetByName(sheetName) || ss.insertSheet(sheetName); // ì‹œíŠ¸ë¥¼ ì°¾ê±°ë‚˜ ìƒˆë¡œ ë§Œë“­ë‹ˆë‹¤.
}


// ì°¸ì„ì ëª©ë¡ì„ ì•± ìƒíƒœì— ì €ì¥í•˜ê³  ì„ íƒëœ ë‚ ì§œë¥¼ ì—…ë°ì´íŠ¸í•˜ëŠ” í•¨ìˆ˜ì…ë‹ˆë‹¤.
function setAttendingPlayersAndDate(playerNames, selectedDate) {
  return safeExecute(() => {
    const state = getAppState(); // í˜„ì¬ ì•± ìƒíƒœë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.
    // [ì˜¤ë¥˜ ìˆ˜ì •] playerNamesê°€ ìœ íš¨í•œ ë°°ì—´ì¸ì§€ í™•ì¸
    if (!Array.isArray(playerNames)) {
      Logger.log("ì˜¤ë¥˜: setAttendingPlayersAndDateì— ìœ íš¨í•˜ì§€ ì•Šì€ playerNamesê°€ ì „ë‹¬ë˜ì—ˆìŠµë‹ˆë‹¤.");
      throw new Error("ì°¸ì„ì ëª©ë¡ ë°ì´í„°ê°€ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.");
    }


    state.attendingPlayerNames = playerNames; // ì°¸ì„ì ì´ë¦„ì„ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.
    state.selectedDate = selectedDate; // ì„ íƒëœ ë‚ ì§œë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.
   
    // ì°¸ì„ì ëª©ë¡ì´ ë³€ê²½ë˜ë©´ playerStatsì˜ ì´ˆê¸°í™”ë„ ë‹¤ì‹œ ìˆ˜í–‰ (ìƒˆë¡œìš´ ì°¸ì„ì ì¶”ê°€ ë“±)
    playerNames.forEach(pName => {
      if (!state.sessionStats.playerStats[pName]) {
        state.sessionStats.playerStats[pName] = { goal: 0, assist: 0, defense: 0, save: 0, gamesPlayed: 0, wins: 0, draws: 0, losses: 0 };
      }
    });


    saveAppState(state); // ë³€ê²½ëœ ìƒíƒœë¥¼ ì €ì¥í•©ë‹ˆë‹¤.
    return state; // ì—…ë°ì´íŠ¸ëœ ìƒíƒœë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
  });
}


// 'ì§€ë‚œ_íŒ€_êµ¬ì„±' ì‹œíŠ¸ì—ì„œ ê³¼ê±° íŒ€ êµ¬ì„± ë°ì´í„°ë¥¼ ê°€ì ¸ì˜¤ëŠ” í•¨ìˆ˜ì…ë‹ˆë‹¤.
function getPastTeamCompositions() {
  const sheet = getSheet(CONFIG.PAST_TEAMS_SHEET); // 'ì§€ë‚œ_íŒ€_êµ¬ì„±' ì‹œíŠ¸ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.
  if (sheet.getLastRow() < 2) return []; // ë°ì´í„°ê°€ ì—†ìœ¼ë©´ ë¹ˆ ë°°ì—´ ë°˜í™˜
 
  // ì²« í–‰ì´ ë¹„ì–´ìˆìœ¼ë©´ í—¤ë”ë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤. (í˜¹ì‹œ ëª¨ë¥¼ ê²½ìš°ë¥¼ ëŒ€ë¹„í•œ ì•ˆì „ ì¥ì¹˜)
  if (sheet.getRange(1, 1).getValue() === "") {
    sheet.appendRow(["ê²½ê¸°ì¼", "ê²½ê¸°ë²ˆí˜¸", "íŒ€ëª…", "í‚¤í¼", "ì„ ìˆ˜1", "ì„ ìˆ˜2", "ì„ ìˆ˜3", "ì„ ìˆ˜4", "ì„ ìˆ˜5", "ì„ ìˆ˜6", "ì„ ìˆ˜7"]); // í‚¤í¼ ì»¬ëŸ¼ ì¶”ê°€
    SpreadsheetApp.flush(); // ë³€ê²½ì‚¬í•­ ì¦‰ì‹œ ë°˜ì˜
  }


  // 2í–‰ë¶€í„° ë§ˆì§€ë§‰ í–‰ê¹Œì§€, 1ì—´ë¶€í„° ë§ˆì§€ë§‰ ì—´ê¹Œì§€ì˜ ë°ì´í„°ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.
  const data = sheet.getRange(2, 1, sheet.getLastRow() - 1, sheet.getLastColumn()).getValues();
 
  // ë°ì´í„°ë¥¼ íŒŒì‹±í•˜ì—¬ [{matchDate, matchNumber, teamName, goalkeeper, players: []}] í˜•íƒœë¡œ ë°˜í™˜í•©ë‹ˆë‹¤.
  return data.map(row => {
    const matchDate = row[0]; // ê²½ê¸°ì¼
    const matchNumber = row[1]; // ê²½ê¸° ë²ˆí˜¸
    const teamName = row[2]; // íŒ€ ì´ë¦„
    const goalkeeper = row[3]; // í‚¤í¼ ì´ë¦„ (ì‹ ê·œ)
    const players = row.slice(4).filter(p => p); // ì„ ìˆ˜ ëª©ë¡ (ë¹ˆ ê°’ ì œê±°, í‚¤í¼ ì œì™¸)
    return { matchDate, matchNumber, teamName, goalkeeper, players };
  });
}


// 'ê¸°ë¡ì‹¤_ê°œì¸ê¸°ë¡' ì‹œíŠ¸ì—ì„œ ì„ ìˆ˜ë³„ ëˆ„ì  ë°ì´í„°ë¥¼ 'í•©ì‚°'í•˜ì—¬ ê°€ì ¸ì˜¤ëŠ” ìˆ˜ì •ëœ í•¨ìˆ˜
function getPlayerStatsFromArchive() {
  const sheet = getSheet(CONFIG.PLAYER_ARCHIVE_SHEET);
  if (sheet.getLastRow() < 2) return {};


  if (sheet.getRange(1, 1).getValue() === "") {
    sheet.appendRow(["ê²½ê¸°ì¼", "ì„ ìˆ˜ëª…", "ê²½ê¸°ìˆ˜", "ìŠ¹", "ë¬´", "íŒ¨", "ë“ì ", "ë„ì›€", "ìˆ˜ë¹„", "ì„ ë°©"]);
    SpreadsheetApp.flush();
  }
 
  const data = sheet.getRange(2, 2, sheet.getLastRow() - 1, 9).getValues();
 
  const playerStats = {};
  data.forEach(row => {
    const playerName = row[0];
    if (!playerStats[playerName]) {
      // ìƒˆë¡œìš´ ì„ ìˆ˜ëŠ” ì´ˆê¸°í™”
      playerStats[playerName] = { games: 0, wins: 0, draws: 0, losses: 0, goal: 0, assist: 0, defense: 0, save: 0 };
    }
    // ê¸°ì¡´ ë°ì´í„°ì— ê³„ì† í•©ì‚°
    playerStats[playerName].games += Number(row[1]) || 0;
    playerStats[playerName].wins += Number(row[2]) || 0;
    playerStats[playerName].draws += Number(row[3]) || 0;
    playerStats[playerName].losses += Number(row[4]) || 0;
    playerStats[playerName].goal += Number(row[5]) || 0;
    playerStats[playerName].assist += Number(row[6]) || 0;
    playerStats[playerName].defense += Number(row[7]) || 0;
    playerStats[playerName].save += Number(row[8]) || 0;
  });
  return playerStats;
}

function performTeamAllocation(algorithm, shuffleEnabled = false) {  // shuffleEnabled íŒŒë¼ë¯¸í„° ì¶”ê°€
  return safeExecute(() => {
    const state = getAppState();
    
    // ìƒˆë¡œìš´ íŒ€ ë°°ë¶„ ì‹œ ì›íŒ€ ë°ì´í„° ì´ˆê¸°í™”
    state.originalTeams = null;
    
    // ì‹œíŠ¸ì—ì„œ ì§ì ‘ ê³„ì‚°ëœ ë°ì´í„° ê°€ì ¸ì˜¤ê¸° (ë¹ ë¥´ê³  ì•ˆì •ì )
    const masterPlayers = getMasterPlayersFromSheet();
    const attendingPlayersData = masterPlayers.filter(p => state.attendingPlayerNames.includes(p.name));
    
    // ì•Œê³ ë¦¬ì¦˜ë³„ ì„¤ì • (mixRatio ì™„ì „ ì œê±°)
    let criteria = 'sheet_only';
    let baseAlgorithm = algorithm;
    
    switch (algorithm) {
      case 'balanced':
      case 'snakeMethod':
      case 'random':
        criteria = 'sheet_only';
        break;
      case 'balanced_ccp':
        criteria = 'mixed_ccp';
        baseAlgorithm = 'balanced';
        break;
      case 'balanced_record':
        criteria = 'ccpBased';
        baseAlgorithm = 'balanced';
        break;
      case 'snake_ccp':
        criteria = 'mixed_ccp';
        baseAlgorithm = 'snakeMethod';
        break;
      case 'snake_record':
        criteria = 'ccpBased';
        baseAlgorithm = 'snakeMethod';
        break;
      case 'mpBased':
        criteria = 'mpBased';
        baseAlgorithm = 'balanced';
        break;
      case 'mpPerGameBased':
        criteria = 'mpPerGameBased';
        baseAlgorithm = 'balanced';
        break;
      case 'winRateBased':
        criteria = 'winRateBased';
        baseAlgorithm = 'balanced';
        break;
    }
    
   
    // ëŠ¥ë ¥ì¹˜ ê³„ì‚° (ê°„ë‹¨í•˜ê³  ëª…í™•í•˜ê²Œ)
    attendingPlayersData.forEach(p => {
      p.power = getPlayerPower(p, criteria);
    });

    // í‹°ì–´ ì…”í”Œ ì ìš©
    if (shuffleEnabled) {
      // ë¨¼ì € íŒŒì›Œ ìˆœìœ¼ë¡œ ì •ë ¬
      attendingPlayersData.sort((a, b) => b.power - a.power);
      
      // 3ê°œ í‹°ì–´ë¡œ ë‚˜ëˆ„ê¸°
      const tierSize = Math.ceil(attendingPlayersData.length / 3);
      
      // ê° í‹°ì–´ ë‚´ë¶€ ì…”í”Œ
      for (let i = 0; i < attendingPlayersData.length; i += tierSize) {
        const tierEnd = Math.min(i + tierSize, attendingPlayersData.length);
        const tier = attendingPlayersData.slice(i, tierEnd);
        
        // Fisher-Yates ì…”í”Œ (ë” ê· ë“±í•œ ëœë¤)
        for (let j = tier.length - 1; j > 0; j--) {
          const randomIndex = Math.floor(Math.random() * (j + 1));
          [tier[j], tier[randomIndex]] = [tier[randomIndex], tier[j]];
        }
        
        // ì…”í”Œëœ í‹°ì–´ë¥¼ ì›ë˜ ìœ„ì¹˜ì— ë‹¤ì‹œ ë„£ê¸°
        attendingPlayersData.splice(i, tier.length, ...tier);
      }
    }
    
    

    let teams = {
      RED: { players: [], goalkeeper: null },
      BLUE: { players: [], goalkeeper: null },
      YELLOW: { players: [], goalkeeper: null }
    };
    const teamNames = Object.keys(teams);

    // ê¸°ë³¸ ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ ë°°ë¶„
    switch (baseAlgorithm) {
      case 'snakeMethod':
        allocateSnakeMethod(attendingPlayersData, teams, teamNames);
        break;
      case 'balanced':
        allocateBalanced(attendingPlayersData, teams, teamNames);
        break;
      default: // 'random'
        allocateRandom(attendingPlayersData, teams, teamNames);
        break;
    }
    
    // ì£¼ì¥/ë¶€ì£¼ì¥ ì„¤ì •
    assignCaptains(teams);
    
    // ìµœì¢… íŒ€ ë°ì´í„° ì„¤ì •
    state.teams = {
      RED: { players: teams.RED.players.map(p => p.name), goalkeeper: teams.RED.goalkeeper, captain: teams.RED.captain, viceCaptain: teams.RED.viceCaptain },
      BLUE: { players: teams.BLUE.players.map(p => p.name), goalkeeper: teams.BLUE.goalkeeper, captain: teams.BLUE.captain, viceCaptain: teams.BLUE.viceCaptain },
      YELLOW: { players: teams.YELLOW.players.map(p => p.name), goalkeeper: teams.YELLOW.goalkeeper, captain: teams.YELLOW.captain, viceCaptain: teams.YELLOW.viceCaptain }
    };

    state.currentScreen = 'screen-team-allocation';
    saveAppState(state);
    return state;
  });
}

function getHybridPlayerPower(player, actualStats, mixRatio, criteria) {
  const sheetPower = player.att + player.def; // ì„ì˜ìŠ¤íƒ¯ (ê³µê²©+ìˆ˜ë¹„)

  if (mixRatio === 0 || criteria === 'sheet_only') {
    return sheetPower;
  }

  let actualPower = 0;
  switch (criteria) {
    case 'ccpBased':
      actualPower = player.ccp || 0;
      break;
    case 'mpBased':
      actualPower = player.mp || 0;
      break;
    case 'mpPerGameBased':
      actualPower = player.mpPerGame || 0;
      break;
    case 'winRateBased':
      actualPower = player.winRate || 0;
      break;
    default:
      actualPower = sheetPower;
      break;
  }
  
  return sheetPower * (1 - mixRatio) + actualPower * mixRatio;
}


// ê²½ê¸° ì‹œì‘ í•¨ìˆ˜ (ê²½ê¸° ì‹œê°„ ì„¤ì • ê¸°ëŠ¥ ë° êµ¬ì¥ëª… ì¶”ê°€)
function startMatch(teamNames, selectedDuration, selectedField) {
  return safeExecute(() => {
    const s = getAppState(); // í˜„ì¬ ì•± ìƒíƒœë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.

    // ì²« ê²½ê¸° ì‹œì‘ ì‹œ ì›íŒ€ ì €ì¥
    if (s.match.count === 1 && !s.originalTeams) {
      s.originalTeams = JSON.parse(JSON.stringify(s.teams));
    }

    // [ì˜¤ë¥˜ ìˆ˜ì •] teamNamesê°€ ìœ íš¨í•œ ë°°ì—´ì¸ì§€ í™•ì¸
    if (!Array.isArray(teamNames) || teamNames.length < 2) {
      Logger.log("ì˜¤ë¥˜: startMatchì— ìœ íš¨í•˜ì§€ ì•Šì€ teamNamesê°€ ì „ë‹¬ë˜ì—ˆìŠµë‹ˆë‹¤.");
      throw new Error("ê²½ê¸° ì‹œì‘ì„ ìœ„í•œ íŒ€ ì„ íƒì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.");
    }

    s.currentScreen = 'screen-match-controller'; // ê²½ê¸° ì»¨íŠ¸ë¡¤ëŸ¬ í™”ë©´ìœ¼ë¡œ ì „í™˜í•©ë‹ˆë‹¤.
    // ê²½ê¸° ì •ë³´ë¥¼ ì´ˆê¸°í™”í•˜ê³  ì„¤ì •í•©ë‹ˆë‹¤. (ì„ íƒëœ ê²½ê¸° ì‹œê°„ ë° êµ¬ì¥ëª… ë°˜ì˜)
    s.match = {
      count: s.match.count,
      playingTeams: teamNames,
      teamA: { name: '', score: 0 }, // íŒ€ ì´ë¦„ì€ ì•„ë˜ì—ì„œ ì„¤ì •
      teamB: { name: '', score: 0 }, // íŒ€ ì´ë¦„ì€ ì•„ë˜ì—ì„œ ì„¤ì •
      timeline: [],
      seconds: selectedDuration, // ì„ íƒëœ ê²½ê¸° ì‹œê°„ìœ¼ë¡œ ì„¤ì •
      timerRunning: false, // íƒ€ì´ë¨¸ ì´ˆê¸°ì—ëŠ” ì •ì§€ ìƒíƒœ
      selectedDuration: selectedDuration, // ì„ íƒëœ ê²½ê¸° ì‹œê°„ ì €ì¥
      todayHeadToHead: s.match.todayHeadToHead || {}, // ì˜¤ëŠ˜ì˜ ìƒëŒ€ ì „ì  ì´ˆê¸°í™” (ê¸°ì¡´ ê°’ ìœ ì§€)
      field: selectedField // ì„ íƒëœ êµ¬ì¥ëª… ì €ì¥
    };
    // í˜„ì¬ ê²½ê¸° íŒ€A, íŒ€B ì´ë¦„ ì„¤ì •
    s.match.teamA.name = teamNames[0];
    s.match.teamB.name = teamNames[1];


    // í˜„ì¬ ì°¸ì„ì ì¤‘ ì„¸ì…˜ í†µê³„ì— ì—†ëŠ” í”Œë ˆì´ì–´ì˜ ì´ˆê¸° ìŠ¤íƒ¯ì„ ì„¤ì •í•©ë‹ˆë‹¤.
    s.attendingPlayerNames.forEach(pName => {
      if (!s.sessionStats.playerStats[pName]) {
        s.sessionStats.playerStats[pName] = { goal: 0, assist: 0, defense: 0, save: 0, gamesPlayed: 0, wins: 0, draws: 0, losses: 0 };
      }
    });
    saveAppState(s); // ë³€ê²½ëœ ìƒíƒœë¥¼ ì €ì¥í•©ë‹ˆë‹¤.
    return s; // ì—…ë°ì´íŠ¸ëœ ìƒíƒœë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
  });
}

function recordEvent(eventData, seconds) {
  const outerStart = new Date().getTime();
  Logger.log('ğŸ”´ recordEvent í•¨ìˆ˜ ì‹œì‘');
  
  const result = safeExecute(() => {
    const innerStart = new Date().getTime();
    Logger.log('ğŸŸ¡ safeExecute ë‚´ë¶€ ì‹œì‘');
    
    const s = getAppState();
    const getStateTime = new Date().getTime();
    Logger.log(`ğŸ“– getAppState ì™„ë£Œ: ${getStateTime - innerStart}ms`);

    // ê¸°ì¡´ ë¡œì§... (ë™ì¼)
    if (!s.match.timerRunning && s.match.seconds > 0) {
      throw new Error("ê²½ê¸°ê°€ ì‹œì‘ë˜ì§€ ì•Šì•˜ê±°ë‚˜ ì¼ì‹œì •ì§€ ìƒíƒœì—ì„œëŠ” ê¸°ë¡í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. íƒ€ì´ë¨¸ë¥¼ ì‹œì‘í•´ì£¼ì„¸ìš”.");
    }
    
    if (typeof seconds === 'number' && !isNaN(seconds)) {
        s.match.seconds = seconds;
    }

    const time = new Date().toLocaleTimeString('en-GB');
    s.match.timeline.unshift({ ...eventData, time });

    const { player, stat, teamName, assistPlayer } = eventData;

    if (s.sessionStats.playerStats[player]) {
      if (stat !== 'ownGoal') {
        s.sessionStats.playerStats[player][stat]++;
      }
    }
    if (stat === 'goal' && assistPlayer && s.sessionStats.playerStats[assistPlayer]) {
      s.sessionStats.playerStats[assistPlayer].assist++;
    }
   
    if (stat === 'goal') {
      const [teamToScore, teamToConcede] = teamName === s.match.teamA.name ? [s.match.teamA, s.match.teamB] : [s.match.teamB, s.match.teamA];
      teamToScore.score++;
      s.sessionStats.teamStats[teamToScore.name].goalsFor++;
      s.sessionStats.teamStats[teamToConcede.name].goalsAgainst++;
    } else if (stat === 'ownGoal') {
      const [scoringTeam, concedingTeam] = teamName === s.match.teamA.name ? [s.match.teamB, s.match.teamA] : [s.match.teamA, s.match.teamB];
      scoringTeam.score++;
      s.sessionStats.teamStats[scoringTeam.name].goalsFor++;
      s.sessionStats.teamStats[concedingTeam.name].goalsAgainst++;
    }

    const beforeSave = new Date().getTime();
    Logger.log(`âš™ï¸ ë¡œì§ ì²˜ë¦¬ ì™„ë£Œ: ${beforeSave - getStateTime}ms`);

    saveAppState(s);
    
    const afterSave = new Date().getTime();
    Logger.log(`ğŸ’¾ saveAppState ì™„ë£Œ: ${afterSave - beforeSave}ms`);

    const innerEnd = new Date().getTime();
    Logger.log(`ğŸŸ¡ safeExecute ë‚´ë¶€ ì™„ë£Œ: ${innerEnd - innerStart}ms`);
    
    return s;
  });

  const outerEnd = new Date().getTime();
  Logger.log(`ğŸ”´ recordEvent í•¨ìˆ˜ ì™„ë£Œ: ${outerEnd - outerStart}ms`);
  
  return result;
}

// ê°€ì¥ ìµœê·¼ ê¸°ë¡ëœ ì´ë²¤íŠ¸ë¥¼ ì·¨ì†Œí•˜ëŠ” í•¨ìˆ˜
function undoLastEvent() {
  return safeExecute(() => {
    const s = getAppState();
    
    // íƒ€ì„ë¼ì¸ì´ ë¹„ì–´ìˆìœ¼ë©´ ì·¨ì†Œí•  ê²ƒì´ ì—†ìŒ
    if (!s.match.timeline || s.match.timeline.length === 0) {
      throw new Error("ì·¨ì†Œí•  ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤.");
    }
    
    // ê°€ì¥ ìµœê·¼ ì´ë²¤íŠ¸ ê°€ì ¸ì˜¤ê¸° (ë°°ì—´ì˜ ì²« ë²ˆì§¸ ìš”ì†Œ)
    const lastEvent = s.match.timeline[0];
    const { player, stat, teamName, assistPlayer } = lastEvent;
    
    // ì„ ìˆ˜ í†µê³„ì—ì„œ í•´ë‹¹ ìŠ¤íƒ¯ ë˜ëŒë¦¬ê¸°
    if (s.sessionStats.playerStats[player] && stat !== 'ownGoal') {
      if (s.sessionStats.playerStats[player][stat] > 0) {
        s.sessionStats.playerStats[player][stat]--;
      }
    }
    
    // ë„ì›€ì´ ìˆì—ˆë˜ ë“ì ì˜ ê²½ìš° ë„ì›€ ì„ ìˆ˜ì˜ assist ìŠ¤íƒ¯ë„ ë˜ëŒë¦¬ê¸°
    if (stat === 'goal' && assistPlayer && s.sessionStats.playerStats[assistPlayer]) {
      if (s.sessionStats.playerStats[assistPlayer].assist > 0) {
        s.sessionStats.playerStats[assistPlayer].assist--;
      }
    }
    
    // ë“ì /ìì±…ê³¨ ê´€ë ¨ íŒ€ ìŠ¤ì½”ì–´ ë° í†µê³„ ë˜ëŒë¦¬ê¸°
    if (stat === 'goal') {
      // ì¼ë°˜ ë“ì ì¸ ê²½ìš°
      const [scoringTeam, concedingTeam] = teamName === s.match.teamA.name 
        ? [s.match.teamA, s.match.teamB] 
        : [s.match.teamB, s.match.teamA];
      
      // íŒ€ ìŠ¤ì½”ì–´ ë˜ëŒë¦¬ê¸°
      if (scoringTeam.score > 0) {
        scoringTeam.score--;
      }
      
      // íŒ€ í†µê³„ ë˜ëŒë¦¬ê¸°
      if (s.sessionStats.teamStats[scoringTeam.name].goalsFor > 0) {
        s.sessionStats.teamStats[scoringTeam.name].goalsFor--;
      }
      if (s.sessionStats.teamStats[concedingTeam.name].goalsAgainst > 0) {
        s.sessionStats.teamStats[concedingTeam.name].goalsAgainst--;
      }
      
    } else if (stat === 'ownGoal') {
      // ìì±…ê³¨ì¸ ê²½ìš° (ìì±…ê³¨ì„ í•œ ì„ ìˆ˜ì˜ ë°˜ëŒ€íŒ€ì´ ë“ì )
      const [scoringTeam, concedingTeam] = teamName === s.match.teamA.name 
        ? [s.match.teamB, s.match.teamA] 
        : [s.match.teamA, s.match.teamB];
      
      // íŒ€ ìŠ¤ì½”ì–´ ë˜ëŒë¦¬ê¸°
      if (scoringTeam.score > 0) {
        scoringTeam.score--;
      }
      
      // íŒ€ í†µê³„ ë˜ëŒë¦¬ê¸°
      if (s.sessionStats.teamStats[scoringTeam.name].goalsFor > 0) {
        s.sessionStats.teamStats[scoringTeam.name].goalsFor--;
      }
      if (s.sessionStats.teamStats[concedingTeam.name].goalsAgainst > 0) {
        s.sessionStats.teamStats[concedingTeam.name].goalsAgainst--;
      }
    }
    
    // íƒ€ì„ë¼ì¸ì—ì„œ í•´ë‹¹ ì´ë²¤íŠ¸ ì œê±°
    s.match.timeline.shift();
    
    // ë³€ê²½ëœ ìƒíƒœ ì €ì¥
    saveAppState(s);
    
    Logger.log(`ì´ë²¤íŠ¸ ì·¨ì†Œ ì™„ë£Œ: ${player}ì˜ ${stat} ê¸°ë¡ì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.`);
    return s;
  });
}

// =================================================================
// íŒŒì¼: Code.gs | 1.2 | [ì†ë„ ê°œì„ ] í•¨ìˆ˜ ìˆ˜ì •: endMatch
// =================================================================
function endMatch() {
  return safeExecute(() => {
    const s = getAppState(); // í˜„ì¬ ì•± ìƒíƒœë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.
    const { teamA, teamB, count } = s.match;
    const teamStats = s.sessionStats.teamStats; // ì„¸ì…˜ íŒ€ í†µê³„
    const playerStats = s.sessionStats.playerStats; // ì„¸ì…˜ ì„ ìˆ˜ í†µê³„

    if (!teamA || !teamA.name || !teamB || !teamB.name) {
      throw new Error("ê²½ê¸° ì¢…ë£Œ ì²˜ë¦¬ë¥¼ ìœ„í•œ íŒ€ ì •ë³´ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤.");
    }

    // --- (ì—¬ê¸°ë¶€í„°) ìŠ¹íŒ¨ ì²˜ë¦¬, ìƒëŒ€ ì „ì  ì—…ë°ì´íŠ¸, ì„ ìˆ˜ë³„ ìŠ¹ë¬´íŒ¨ ì—…ë°ì´íŠ¸ ë“± ---
    // --- (ì´ ë¶€ë¶„ì˜ ê¸°ì¡´ ë¡œì§ì€ ë³€ê²½ ì—†ì´ ê·¸ëŒ€ë¡œ ìœ ì§€ë©ë‹ˆë‹¤) ---
    if (teamA.score === teamB.score) {
      teamStats[teamA.name].draws++;
      teamStats[teamB.name].draws++;
    } else {
      const winner = teamA.score > teamB.score ? teamA.name : teamB.name;
      const loser = winner === teamA.name ? teamB.name : teamA.name;
      teamStats[winner].wins++;
      teamStats[loser].losses++;
    }
    const teamA_name = teamA.name;
    const teamB_name = teamB.name;
    const headToHeadKey = [teamA_name, teamB_name].sort().join('_');
    if (!s.match.todayHeadToHead[headToHeadKey]) {
      s.match.todayHeadToHead[headToHeadKey] = { [teamA_name]: { wins: 0, draws: 0, losses: 0 }, [teamB_name]: { wins: 0, draws: 0, losses: 0 } };
    }
    if (teamA.score === teamB.score) {
      s.match.todayHeadToHead[headToHeadKey][teamA_name].draws++;
      s.match.todayHeadToHead[headToHeadKey][teamB_name].draws++;
    } else {
      const winner = teamA.score > teamB.score ? teamA_name : teamB_name;
      const loser = winner === teamA.name ? teamB.name : teamA.name;
      s.match.todayHeadToHead[headToHeadKey][winner].wins++;
      s.match.todayHeadToHead[headToHeadKey][loser].losses++;
    }
    const allPlayersInMatch = [...s.teams[teamA.name].players, ...s.teams[teamB.name].players];
    const allGoalkeepersInMatch = [s.teams[teamA.name].goalkeeper, s.teams[teamB.name].goalkeeper].filter(Boolean);
    const uniquePlayersInMatch = new Set([...allPlayersInMatch, ...allGoalkeepersInMatch]);
    uniquePlayersInMatch.forEach(pName => {
      if (!playerStats[pName]) {
        playerStats[pName] = { goal: 0, assist: 0, defense: 0, save: 0, gamesPlayed: 0, wins: 0, draws: 0, losses: 0 };
      }
      playerStats[pName].gamesPlayed++;
      if (teamA.score === teamB.score) {
        playerStats[pName].draws++;
      } else {
        const winner = teamA.score > teamB.score ? teamA.name : teamB.name;
        if ((s.teams[winner].players.includes(pName) || s.teams[winner].goalkeeper === pName)) {
          playerStats[pName].wins++;
        } else {
          playerStats[pName].losses++;
        }
      }
    });
    const allTeamNames = ['RED', 'BLUE', 'YELLOW'];
    allTeamNames.forEach(name => {
      if (name === teamA_name || name === teamB_name) {
        teamStats[name].matchesPlayed++;
        teamStats[name].consecutivePlays++;
      } else {
        teamStats[name].consecutivePlays = 0;
      }
    });
    // --- (ì—¬ê¸°ê¹Œì§€ì˜ ê¸°ì¡´ ë¡œì§ì€ ëª¨ë‘ ë™ì¼í•©ë‹ˆë‹¤) ---


    // â–¼â–¼â–¼ [í•µì‹¬ ë³€ê²½] ìŠ¤í”„ë ˆë“œì‹œíŠ¸ì— ì§ì ‘ ê¸°ë¡í•˜ëŠ” ëŒ€ì‹ , ì„ì‹œ ì €ì¥ ê³µê°„(matchHistory)ì— ë°ì´í„°ë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤. â–¼â–¼â–¼
    const date = Utilities.formatDate(new Date(), SpreadsheetApp.getActive().getSpreadsheetTimeZone(), "yyyy-MM-dd");
    [s.match.teamA.name, s.match.teamB.name].forEach(teamName => {
      const teamData = s.teams[teamName];
      if (teamData.players.length > 0 || teamData.goalkeeper) {
        // matchHistory ë°°ì—´ì— ê²½ê¸° ê²°ê³¼ ê°ì²´ë¥¼ ì¶”ê°€
        s.sessionResults.matchHistory.push({
          date: date,
          matchNumber: count, // í˜„ì¬ ê²½ê¸° ë²ˆí˜¸
          teamName: teamName,
          goalkeeper: teamData.goalkeeper || '',
          players: teamData.players
        });
        Logger.log(`ë©”ëª¨ë¦¬ì— ê²½ê¸° ê¸°ë¡ ì €ì¥ ì™„ë£Œ: ${teamName} - ê²½ê¸° #${count}`);
      }
    });
    // â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²

    s.match.count++; // ë‹¤ìŒ ê²½ê¸°ë¥¼ ìœ„í•´ ê²½ê¸° ìˆ˜ ì¦ê°€
    s.match.timerRunning = false;

    // --- (ì—¬ê¸°ë¶€í„°) ë‹¤ìŒ ê²½ê¸° ìë™ ì„¤ì • ë¡œì§ì€ ë³€ê²½ ì—†ì´ ê·¸ëŒ€ë¡œ ìœ ì§€ë©ë‹ˆë‹¤ ---
    const currentPlayingTeams = [teamA_name, teamB_name];
    const waitingTeam = allTeamNames.find(name => !currentPlayingTeams.includes(name));
    let consecutivePlayedTeam = null;
    if (teamStats[teamA_name].consecutivePlays >= 3) {
      consecutivePlayedTeam = teamA_name;
    } else if (teamStats[teamB_name].consecutivePlays >= 3) {
      consecutivePlayedTeam = teamB_name;
    }
    if (consecutivePlayedTeam) {
      s.currentScreen = 'screen-match-controller';
      s.match.nextMatchSuggestion = {
        type: 'consecutive',
        team: consecutivePlayedTeam,
        suggestedTeams: allTeamNames.filter(t => t !== consecutivePlayedTeam)
      };
    } else if (teamA.score === teamB.score) {
      s.currentScreen = 'screen-match-controller';
      s.match.nextMatchSuggestion = {
        type: 'draw',
        drawingTeams: [teamA_name, teamB_name],
        waitingTeam: waitingTeam
      };
    } else {
      const winner = teamA.score > teamB.score ? teamA_name : teamB_name;
      const nextPlayingTeams = [winner, waitingTeam].filter(Boolean);
      if (nextPlayingTeams.length < 2) {
        s.currentScreen = 'screen-match-select';
      } else {
        s.match.playingTeams = nextPlayingTeams;
        s.match.teamA = { name: nextPlayingTeams[0], score: 0 };
        s.match.teamB = { name: nextPlayingTeams[1], score: 0 };
        s.match.timeline = [];
        s.match.seconds = s.match.selectedDuration;
        s.match.timerRunning = false;
        s.currentScreen = 'screen-match-controller';
      }
    }
    // --- (ì—¬ê¸°ê¹Œì§€ ë‹¤ìŒ ê²½ê¸° ìë™ ì„¤ì • ë¡œì§ì€ ë™ì¼í•©ë‹ˆë‹¤) ---
   
    saveAppState(s);
    return s;
  });
}


// íƒ€ì´ë¨¸ ìƒíƒœë¥¼ ì €ì¥í•˜ëŠ” í•¨ìˆ˜ì…ë‹ˆë‹¤. (ë‚¨ì€ ì‹œê°„ ì—…ë°ì´íŠ¸ ê¸°ëŠ¥ ì¶”ê°€)
function toggleTimerState(running, seconds) { // ğŸ‘ˆ 1. seconds íŒŒë¼ë¯¸í„°ê°€ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤.
  return safeExecute(() => {
    const state = getAppState(); // í˜„ì¬ ì•± ìƒíƒœë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.
    state.match.timerRunning = running; // íƒ€ì´ë¨¸ ì‹¤í–‰ ìƒíƒœ ì—…ë°ì´íŠ¸
   
    // ğŸ‘‡ 2. ì´ if ë¬¸ì´ ìƒˆë¡œ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤.
    // seconds ê°’ì´ ìœ íš¨í•œ ìˆ«ìë¡œ ì „ë‹¬ëœ ê²½ìš°ì—ë§Œ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.
    if (typeof seconds === 'number' && !isNaN(seconds)) {
        state.match.seconds = seconds;
    }


    saveAppState(state); // ë³€ê²½ëœ ìƒíƒœ ì €ì¥
    return state; // ì—…ë°ì´íŠ¸ëœ ìƒíƒœë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
  });
}
// [ì‹ ê·œ] íŠ¹ì • íŒ€ì˜ ê³¨í‚¤í¼ë¥¼ ì§€ì •í•˜ëŠ” í•¨ìˆ˜ì…ë‹ˆë‹¤.
// teamName: í‚¤í¼ë¥¼ ì§€ì •í•  íŒ€ì˜ ì´ë¦„ (RED, BLUE, YELLOW)
// goalkeeperName: í‚¤í¼ë¡œ ì§€ì •í•  ì„ ìˆ˜ì˜ ì´ë¦„ (ì–´ë–¤ íŒ€ ì†Œì†ì´ë“  ê°€ëŠ¥)
function setGoalkeeper(teamName, goalkeeperName) {
  return safeExecute(() => {
    const state = getAppState(); // í˜„ì¬ ì•± ìƒíƒœë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.
   
    // [ì˜¤ë¥˜ ìˆ˜ì •] teamNameì´ ìœ íš¨í•œì§€ í™•ì¸
    if (!state.teams[teamName]) {
      Logger.log(`ì˜¤ë¥˜: ì¡´ì¬í•˜ì§€ ì•ŠëŠ” íŒ€ ì´ë¦„ì…ë‹ˆë‹¤: ${teamName}`);
      throw new Error(`ì¡´ì¬í•˜ì§€ ì•ŠëŠ” íŒ€ ì´ë¦„ì…ë‹ˆë‹¤: ${teamName}`);
    }


    // ì§€ì •í•  ì„ ìˆ˜ê°€ ì°¸ì„ì ëª©ë¡ì— ìˆëŠ”ì§€ í™•ì¸ (í•„ìˆ˜ëŠ” ì•„ë‹ˆì§€ë§Œ, ì—ëŸ¬ ë°©ì§€)
    if (goalkeeperName && !state.attendingPlayerNames.includes(goalkeeperName)) {
      Logger.log(`ê²½ê³ : ${goalkeeperName} ì„ ìˆ˜ëŠ” ì°¸ì„ì ëª©ë¡ì— ì—†ìŠµë‹ˆë‹¤. í‚¤í¼ë¡œ ì§€ì •í•©ë‹ˆë‹¤.`);
      // ì°¸ì„ì ëª©ë¡ì— ì—†ì–´ë„ í‚¤í¼ë¡œ ì§€ì •ì€ ê°€ëŠ¥í•˜ê²Œ í•˜ë˜, ê²½ê³  ë¡œê·¸ ë‚¨ê¹€
      // í•„ìš”ì‹œ throw new Error("ì°¸ì„ì ëª©ë¡ì— ì—†ëŠ” ì„ ìˆ˜ëŠ” í‚¤í¼ë¡œ ì§€ì •í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.") ë¡œ ë³€ê²½ ê°€ëŠ¥
    }


    // í•´ë‹¹ íŒ€ì˜ ê³¨í‚¤í¼ë¥¼ ì§€ì •í•©ë‹ˆë‹¤.
    state.teams[teamName].goalkeeper = goalkeeperName;
    Logger.log(`${teamName} íŒ€ì˜ í‚¤í¼ê°€ ${goalkeeperName || 'ë¯¸ì§€ì •'} (ìœ¼)ë¡œ ì§€ì •ë˜ì—ˆìŠµë‹ˆë‹¤.`);


    saveAppState(state); // ë³€ê²½ëœ ìƒíƒœë¥¼ ì €ì¥í•©ë‹ˆë‹¤.
    return state; // ì—…ë°ì´íŠ¸ëœ ìƒíƒœë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
  });
}


// [ìˆ˜ì •ëœ substitutePlayer í•¨ìˆ˜]
function substitutePlayer(teamName, playerOutName, playerInName) {
    return safeExecute(() => {
        const state = getAppState();
        const teamPlayers = state.teams[teamName].players;
        const playerOutIndex = teamPlayers.indexOf(playerOutName);
        if (playerOutIndex === -1) {
            Logger.log(`ì˜¤ë¥˜: ${playerOutName} ì„ ìˆ˜ëŠ” ${teamName} íŒ€ì˜ í•„ë“œ í”Œë ˆì´ì–´ì— ì—†ìŠµë‹ˆë‹¤.`);
            throw new Error(`${playerOutName} ì„ ìˆ˜ëŠ” ${teamName} íŒ€ì˜ í•„ë“œ í”Œë ˆì´ì–´ì— ì—†ìŠµë‹ˆë‹¤.`);
        }


        if (playerInName) {
            // êµì²´ íˆ¬ì…í•  ì„ ìˆ˜ê°€ ë‹¤ë¥¸ íŒ€ì— ìˆëŠ”ì§€ í™•ì¸
            const allTeamNames = ['RED', 'BLUE', 'YELLOW'];
            let otherTeamName = null;
            let otherTeamPlayerIndex = -1;
            let isGoalkeeper = false;


            allTeamNames.forEach(tName => {
                if (tName !== teamName) {
                    // í•„ë“œ í”Œë ˆì´ì–´ì—ì„œ ì°¾ê¸°
                    const index = state.teams[tName].players.indexOf(playerInName);
                    if (index !== -1) {
                        otherTeamName = tName;
                        otherTeamPlayerIndex = index;
                    }
                    // ê³¨í‚¤í¼ì—ì„œ ì°¾ê¸°
                    if (state.teams[tName].goalkeeper === playerInName) {
                        otherTeamName = tName;
                        isGoalkeeper = true;
                    }
                }
            });


            // êµì²´ íˆ¬ì…í•  ì„ ìˆ˜ê°€ ë‹¤ë¥¸ íŒ€ì— ìˆë‹¤ë©´,
            if (otherTeamName) {
                // ê¸°ì¡´ ì„ ìˆ˜ì™€ êµì²´
                if (isGoalkeeper) {
                    // êµì²´ íˆ¬ì… ì„ ìˆ˜ê°€ í‚¤í¼ì¼ ê²½ìš°
                    state.teams[otherTeamName].goalkeeper = playerOutName;
                } else {
                    // êµì²´ íˆ¬ì… ì„ ìˆ˜ê°€ í•„ë“œ í”Œë ˆì´ì–´ì¼ ê²½ìš°
                    state.teams[otherTeamName].players[otherTeamPlayerIndex] = playerOutName;
                }
                Logger.log(`${otherTeamName} íŒ€ì˜ ${playerInName} ì„ ìˆ˜ê°€ ${playerOutName} ì„ ìˆ˜ë¡œ êµì²´ë˜ì—ˆìŠµë‹ˆë‹¤.`);
            } else {
                // êµì²´ íˆ¬ì… ì„ ìˆ˜ê°€ ëŒ€ê¸° ì¤‘ì¸ ì„ ìˆ˜ì¼ ê²½ìš°
                const waitingPlayerIndex = state.attendingPlayerNames.indexOf(playerInName);
                if (waitingPlayerIndex !== -1) {
                    state.attendingPlayerNames.splice(waitingPlayerIndex, 1);
                }
                state.attendingPlayerNames.push(playerOutName);
                Logger.log(`${playerInName} ì„ ìˆ˜ê°€ ëŒ€ê¸° ì„ ìˆ˜ì—ì„œ ${teamName} íŒ€ìœ¼ë¡œ ì´ë™í–ˆìŠµë‹ˆë‹¤.`);
            }


            // ê¸°ì¡´ íŒ€ ì„ ìˆ˜ êµì²´
            teamPlayers[playerOutIndex] = playerInName;


            Logger.log(`${teamName} íŒ€ì—ì„œ ${playerOutName} ì„ ìˆ˜ê°€ ${playerInName} ì„ ìˆ˜ë¡œ êµì²´ë˜ì—ˆìŠµë‹ˆë‹¤.`);
        } else {
            // ë“¤ì–´ì˜¬ ì„ ìˆ˜ê°€ nullì¸ ê²½ìš° (ë‹¨ìˆœíˆ ì„ ìˆ˜ ì œê±°)
            teamPlayers.splice(playerOutIndex, 1);
            Logger.log(`${teamName} íŒ€ì—ì„œ ${playerOutName} ì„ ìˆ˜ê°€ ì œê±°ë˜ì—ˆìŠµë‹ˆë‹¤.`);
        }


        saveAppState(state);
        return state;
    });
}


// [ì‹ ê·œ] ë¬´ìŠ¹ë¶€ ì‹œ ë‹¤ìŒ ê²½ê¸°ë¥¼ ì§„í–‰í•  íŒ€ì„ ì„ íƒí•˜ëŠ” í•¨ìˆ˜
function selectNextPlayingTeam(selectedTeamName) {
  return safeExecute(() => {
    const s = getAppState();
    const { teamA, teamB } = s.match;
    const allTeamNames = ['RED', 'BLUE', 'YELLOW'];
    const waitingTeam = allTeamNames.find(name => name !== teamA.name && name !== teamB.name);


    // [ì˜¤ë¥˜ ìˆ˜ì •] selectedTeamNameì´ ìœ íš¨í•œì§€ í™•ì¸
    if (!allTeamNames.includes(selectedTeamName)) {
      Logger.log(`ì˜¤ë¥˜: ìœ íš¨í•˜ì§€ ì•Šì€ íŒ€ ì´ë¦„ì…ë‹ˆë‹¤: ${selectedTeamName}`);
      throw new Error("ìœ íš¨í•˜ì§€ ì•Šì€ íŒ€ ì´ë¦„ì…ë‹ˆë‹¤.");
    }
   
    const nextPlayingTeams = [selectedTeamName, waitingTeam].filter(Boolean);


    if (nextPlayingTeams.length < 2) {
      s.currentScreen = 'screen-match-select'; // íŒ€ì´ ë¶€ì¡±í•˜ë©´ ê²½ê¸° ì„ íƒ í™”ë©´ìœ¼ë¡œ
      Logger.log("ë‹¤ìŒ ê²½ê¸° ì§„í–‰í•  íŒ€ì´ ë¶€ì¡±í•˜ì—¬ ê²½ê¸° ì„ íƒ í™”ë©´ìœ¼ë¡œ ì´ë™.");
    } else {
      s.match.playingTeams = nextPlayingTeams;
      s.match.teamA = { name: nextPlayingTeams[0], score: 0 };
      s.match.teamB = { name: nextPlayingTeams[1], score: 0 };
      s.match.timeline = []; // íƒ€ì„ë¼ì¸ ì´ˆê¸°í™”
      s.match.seconds = s.match.selectedDuration; // ì‹œê°„ ì´ˆê¸°í™”
      s.match.timerRunning = false; // íƒ€ì´ë¨¸ ì •ì§€
      s.currentScreen = 'screen-match-controller';
      Logger.log(`ë¬´ìŠ¹ë¶€ í›„ ë‹¤ìŒ ê²½ê¸° ì„¤ì •: ${nextPlayingTeams[0]} vs ${nextPlayingTeams[1]}`);
    }
    s.match.nextMatchSuggestion = null; // ì œì•ˆ ì´ˆê¸°í™”
    saveAppState(s);
    return s;
  });
}


// [ì‹ ê·œ] 3ê²½ê¸° ì—°ì† ê²½ê¸° í›„ ë‹¤ìŒ ê²½ê¸° ì§„í–‰ ì—¬ë¶€ í™•ì¸ í•¨ìˆ˜
function confirmNextMatch(confirmProceed) {
  return safeExecute(() => {
    const s = getAppState();
    // [ì˜¤ë¥˜ ìˆ˜ì •] s.match.nextMatchSuggestionì´ ìœ íš¨í•œì§€ í™•ì¸
    if (!s.match.nextMatchSuggestion || !s.match.nextMatchSuggestion.team) {
      Logger.log("ì˜¤ë¥˜: confirmNextMatch í•¨ìˆ˜ í˜¸ì¶œ ì‹œ ë‹¤ìŒ ê²½ê¸° ì œì•ˆ ì •ë³´ê°€ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.");
      throw new Error("ë‹¤ìŒ ê²½ê¸° ì œì•ˆ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
    }


    const allTeamNames = ['RED', 'BLUE', 'YELLOW'];
    const consecutivePlayedTeam = s.match.nextMatchSuggestion.team; // 3ì—°ì† ë›´ íŒ€
   
    // 3ì—°ì† ë›´ íŒ€ì„ ì œì™¸í•œ ë‚˜ë¨¸ì§€ ë‘ íŒ€ì„ ì°¾ìŒ
    const suggestedNextTeams = allTeamNames.filter(name => name !== consecutivePlayedTeam);


    if (confirmProceed) { // 'ì˜ˆ'ë¥¼ ì„ íƒí•œ ê²½ìš° (ë‚˜ë¨¸ì§€ ë‘ íŒ€ì´ ê²½ê¸°)
      if (suggestedNextTeams.length < 2) { // í˜¹ì‹œ ëª¨ë¥¼ ê²½ìš° (íŒ€ì´ 2ê°œ ì´í•˜ì¼ ë•Œ)
        s.currentScreen = 'screen-match-select';
        Logger.log("3ì—°ì† ê²½ê¸° í›„ ê°•ì œ ì„¤ì •í•  íŒ€ì´ ë¶€ì¡±í•˜ì—¬ ê²½ê¸° ì„ íƒ í™”ë©´ìœ¼ë¡œ ì´ë™.");
      } else {
        s.match.playingTeams = suggestedNextTeams;
        s.match.teamA = { name: suggestedNextTeams[0], score: 0 };
        s.match.teamB = { name: suggestedNextTeams[1], score: 0 };
        s.match.timeline = []; // íƒ€ì„ë¼ì¸ ì´ˆê¸°í™”
        s.match.seconds = s.match.selectedDuration; // ì‹œê°„ ì´ˆê¸°í™”
        s.match.timerRunning = false; // íƒ€ì´ë¨¸ ì •ì§€
        s.currentScreen = 'screen-match-controller';
        Logger.log(`3ì—°ì† ê²½ê¸° í›„ ë‹¤ìŒ ê²½ê¸° ê°•ì œ ì„¤ì •: ${suggestedNextTeams[0]} vs ${suggestedNextTeams[1]}`);
      }
    } else { // 'ì•„ë‹ˆì˜¤'ë¥¼ ì„ íƒí•œ ê²½ìš° (ê²½ê¸° ì„ íƒ í™”ë©´ìœ¼ë¡œ ì´ë™)
      s.currentScreen = 'screen-match-select';
      Logger.log("3ì—°ì† ê²½ê¸° í›„ ì‚¬ìš©ì ì„ íƒì— ë”°ë¼ ê²½ê¸° ì„ íƒ í™”ë©´ìœ¼ë¡œ ì´ë™.");
    }
    s.match.nextMatchSuggestion = null; // ì œì•ˆ ì´ˆê¸°í™”
    saveAppState(s);
    return s;
  });
}


// [ì‹ ê·œ] ì„¸ì…˜ ì¢…ë£Œ ì‹œ ìµœì¢… ê²°ê³¼ ê³„ì‚° ë° ìš”ì•½ í™”ë©´ìœ¼ë¡œ ì´ë™í•˜ëŠ” í•¨ìˆ˜
function finishSessionToSummary() {
  return safeExecute(() => {
    const s = getAppState();
    const playerStats = s.sessionStats.playerStats;
    // masterPlayersì™€ playerArchiveStatsëŠ” ì´ì œ ì‚¬ìš©ë˜ì§€ ì•Šì§€ë§Œ, í–¥í›„ ê¸°ëŠ¥ì„ ìœ„í•´ ë‚¨ê²¨ë‘¡ë‹ˆë‹¤.
    const masterPlayers = getMasterPlayersFromSheet(); 
    const playerArchiveStats = getPlayerStatsFromArchive();

    // MVP, ìµœìš°ìˆ˜ ìˆ˜ë¹„ìˆ˜, ìµœìš°ìˆ˜ ê³¨í‚¤í¼ ì„ ì •
    let mvp = null;
    let maxMvPScore = -1;
    let bestDefender = null;
    let maxDefense = -1;
    let bestGoalkeeper = null;
    let maxSave = -1;

    Object.keys(playerStats).forEach(pName => {
      const stats = playerStats[pName];
      const mvpScore = (stats.goal * 2) + (stats.assist * 2) + (stats.defense * 1) + (stats.save * 1);
     
      // MVP ì„ ì •
      if (mvpScore > maxMvPScore) {
        maxMvPScore = mvpScore;
        mvp = pName;
      }
      
      // â–¼â–¼â–¼ [í•µì‹¬ ìˆ˜ì •] ì—­í• (Role) êµ¬ë¶„ ì—†ì´, ë‹¨ìˆœíˆ ìˆ˜ë¹„ ìŠ¤íƒ¯ì´ ê°€ì¥ ë†’ì€ ì„ ìˆ˜ë¥¼ ì„ ì •í•©ë‹ˆë‹¤. â–¼â–¼â–¼
      if (stats.defense > maxDefense) {
        maxDefense = stats.defense;
        bestDefender = pName;
      }
      // â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²
     
      // ìµœìš°ìˆ˜ ê³¨í‚¤í¼ (ì„ ë°© ê¸°ë¡ì´ ê°€ì¥ ë†’ì€ ì„ ìˆ˜)
      if (stats.save > maxSave) {
        maxSave = stats.save;
        bestGoalkeeper = pName;
      }
    });

    // ìœ ì˜ë¯¸í•œ ê¸°ë¡ì´ ìˆì„ ë•Œë§Œ ìˆ˜ìƒìë¥¼ ì„ ì •í•©ë‹ˆë‹¤.
    if (maxMvPScore === 0) mvp = null;
    if (maxDefense === 0) bestDefender = null;
    if (maxSave === 0) bestGoalkeeper = null;
    
    // sessionResults ê°ì²´ì— ë‹¤ë¥¸ ì •ë³´ê°€ ìˆì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ, ê¸°ì¡´ ì •ë³´ë¥¼ ìœ ì§€í•˜ë©° ìˆ˜ìƒì ì •ë³´ë§Œ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.
    s.sessionResults = {
      ...s.sessionResults, // ê¸°ì¡´ sessionResults ì •ë³´ (ì˜ˆ: matchHistory) ìœ ì§€
      mvp: mvp,
      bestDefender: bestDefender,
      bestGoalkeeper: bestGoalkeeper
    };
    
    s.currentScreen = 'screen-session-summary';
    saveAppState(s);
    return s;
  });
}

// =================================================================
// íŒŒì¼: Code.gs | 1.3 | [ë°°ì¹˜ ì“°ê¸° ì ìš©] í•¨ìˆ˜ ìˆ˜ì •: updateAndArchiveSession
// =================================================================
function updateAndArchiveSession() {
  return safeExecute(() => {
    const state = getAppState();
    const date = Utilities.formatDate(new Date(), SpreadsheetApp.getActive().getSpreadsheetTimeZone(), "yyyy-MM-dd");
   
    const archiveSheet = getSheet(CONFIG.PLAYER_ARCHIVE_SHEET);
    const rowsToAdd = Object.keys(state.sessionStats.playerStats)
      .filter(pName => state.sessionStats.playerStats[pName].gamesPlayed > 0)
      .map(pName => {
        const stat = state.sessionStats.playerStats[pName];
        return [date, pName, stat.gamesPlayed, stat.wins, stat.draws, stat.losses, stat.goal, stat.assist, stat.defense, stat.save];
      });
    if(rowsToAdd.length > 0) {
    // Kì—´(11ë²ˆì§¸ ì—´)ê¹Œì§€ë§Œ ì²´í¬í•˜ì—¬ ì‹¤ì œ ë°ì´í„°ê°€ ìˆëŠ” ë§ˆì§€ë§‰ í–‰ ì°¾ê¸°
    let lastDataRow = 1; // í—¤ë” í–‰
    const dataRange = archiveSheet.getRange(1, 1, archiveSheet.getLastRow(), 10).getValues();
    
    for(let i = dataRange.length - 1; i >= 1; i--) {
        if(dataRange[i][1]) { // Bì—´(ì„ ìˆ˜ëª…)ì— ê°’ì´ ìˆìœ¼ë©´
            lastDataRow = i + 1;
            break;
        }
    }
    
    // ì‹¤ì œ ë°ì´í„° ë‹¤ìŒ í–‰ë¶€í„° ì¶”ê°€
    archiveSheet.getRange(lastDataRow + 1, 1, rowsToAdd.length, rowsToAdd[0].length).setValues(rowsToAdd);
}
    
    const pastTeamsSheet = getSheet(CONFIG.PAST_TEAMS_SHEET);
    const teamRowsToAdd = state.sessionResults.matchHistory.map(match => {
        const players = match.players.slice(0, 7);
        while(players.length < 7) {
            players.push('');
        }
        return [match.date, match.matchNumber, match.teamName, match.goalkeeper, ...players];
    });

    if (teamRowsToAdd.length > 0) {
        if(pastTeamsSheet.getRange(1,1).getValue() === "") {
            pastTeamsSheet.appendRow(["ê²½ê¸°ì¼", "ê²½ê¸°ë²ˆí˜¸", "íŒ€ëª…", "í‚¤í¼", "ì„ ìˆ˜1", "ì„ ìˆ˜2", "ì„ ìˆ˜3", "ì„ ìˆ˜4", "ì„ ìˆ˜5", "ì„ ìˆ˜6", "ì„ ìˆ˜7"]);
        }
        pastTeamsSheet.getRange(pastTeamsSheet.getLastRow() + 1, 1, teamRowsToAdd.length, teamRowsToAdd[0].length).setValues(teamRowsToAdd);
    }
    
    SpreadsheetApp.flush();
    
    // ì•± ìƒíƒœ ì‹œíŠ¸ë„ ì´ˆê¸°í™”
    const stateSheet = getSheet(CONFIG.APP_STATE_SHEET);
    stateSheet.clear();
    
    return getAppState();
  });
}

// [ì‹ ê·œ] ì„¸ì…˜ ë‚´ ì„ ìˆ˜ ê°œì¸ ìŠ¤íƒ¯ì„ ì—…ë°ì´íŠ¸í•˜ëŠ” í•¨ìˆ˜ (ê¸°ë¡ ìˆ˜ì • í™”ë©´ì—ì„œ ì‚¬ìš©)
function updateSessionPlayerStats(playerName, statType, newValue) {
  return safeExecute(() => {
    const s = getAppState();
    if (s.sessionStats.playerStats[playerName]) {
      const oldValue = s.sessionStats.playerStats[playerName][statType];
      s.sessionStats.playerStats[playerName][statType] = Number(newValue) || 0;


      // ë“ì /ì‹¤ì  ì—°ë™ ë¡œì§
      if (statType === 'goal') {
        const diff = (Number(newValue) || 0) - oldValue;
        // ì´ ë¡œì§ì€ í•´ë‹¹ ì„ ìˆ˜ê°€ íŠ¹ì • íŒ€ì— ì†í–ˆë‹¤ëŠ” ê°€ì •ì´ í•„ìš” (í˜„ì¬ëŠ” ì´ ì •ë³´ê°€ ì„¸ì…˜ ìŠ¤íƒ¯ì— ì§ì ‘ ì—†ìŒ)
        // ê°€ì¥ ìµœê·¼ì˜ ê²½ê¸°ì—ì„œ í•´ë‹¹ ì„ ìˆ˜ê°€ ì†í–ˆë˜ íŒ€ì˜ ë“ì‹¤ì°¨ë¥¼ ì¶”ì í•´ì•¼ í•˜ì§€ë§Œ,
        // ì—¬ê¸°ì„œëŠ” í•´ë‹¹ ì„ ìˆ˜ê°€ ì–´ëŠ íŒ€ì— ì†í–ˆì—ˆëŠ”ì§€ ì§ì ‘ì ì¸ ì—°ê²°ì´ ì—†ìœ¼ë¯€ë¡œ,
        // ì„¸ì…˜ ë‚´ íŒ€ë³„ ë“ì‹¤ì ì€ 'ê²½ê¸° ì¢…ë£Œ' ì‹œì ì—ë§Œ ì—…ë°ì´íŠ¸í•˜ëŠ” ê²ƒì´ í˜„ì‹¤ì ì…ë‹ˆë‹¤.
        // ë”°ë¼ì„œ ê¸°ë¡ ìˆ˜ì • í™”ë©´ì—ì„œ 'ê³¨' ìŠ¤íƒ¯ì„ ì§ì ‘ ìˆ˜ì •í•˜ëŠ” ê²½ìš°, íŒ€ì˜ ë“ì‹¤ì ì€ ìë™ ì—…ë°ì´íŠ¸ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
        // ì´ëŠ” UI/UX ì„¤ê³„ ì‹œ ì‚¬ìš©ìê°€ ì´í•´í•˜ë„ë¡ ì•ˆë‚´í•´ì•¼ í•  ë¶€ë¶„ì…ë‹ˆë‹¤.
        // (í˜„ì¬ëŠ” updateSessionPlayerStatsì—ì„œ teamNameForGoalUpdateë¥¼ ë°›ì§€ ì•Šìœ¼ë¯€ë¡œ ì—°ë™ ë¡œì§ì€ ë¹„í™œì„±í™”)
      }
     
    }
    saveAppState(s);
    return s;
  });
}


// ì„ ìˆ˜ ëŠ¥ë ¥ì¹˜ë¥¼ ê³„ì‚°í•˜ëŠ” í•¨ìˆ˜
function getPlayerPower(player, criteria) {
  switch (criteria) {
    case 'sheet_only':
      return player.att + player.def; // ì„ì˜ìŠ¤íƒ¯ (ê³µê²©+ìˆ˜ë¹„)
    case 'ccpBased':
      return player.ccp || 0;
    case 'mpBased':
      return player.mp || 0;
    case 'mpPerGameBased':
      return player.mpPerGame || 0;
    case 'winRateBased':
      return player.winRate || 0;
    case 'mixed_ccp':
      return ((player.att + player.def) + (player.ccp || 0)) / 2; // 50:50 í˜¼í•©
    default:
      return player.att + player.def;
  }
}

// 1. ìŠ¤ë„¤ì´í¬ ë°©ì‹ (ê¸°ì¡´)
function allocateSnakeMethod(players, teams, teamNames) {
    players.sort((a, b) => b.power - a.power);
    let currentTeamIndex = 0;
    let direction = 1;
    
    players.forEach(player => {
        teams[teamNames[currentTeamIndex]].players.push(player);
        currentTeamIndex += direction;
        if (currentTeamIndex >= teamNames.length || currentTeamIndex < 0) {
            direction *= -1;
            currentTeamIndex += direction;
        }
    });
}




/**
 * 3íŒ€ ê³ ì • ì´ˆê°„ë‹¨ ë°°ë¶„
 * - 18ëª…: 6ëª…ì”©, 21ëª…: 7ëª…ì”©
 * - ê·¸ ì™¸: íŒ€ ê°„ ì¸ì› ì°¨ì´ ìµœëŒ€ 1
 * - ë¡œì§: ë†’ì€ íŒŒì›Œ ìˆœìœ¼ë¡œ ì •ë ¬ â†’ ì•„ì§ ëœ ì°¬ íŒ€ ì¤‘ í•©ê³„ íŒŒì›Œê°€ ë‚®ì€ íŒ€ì— ë°°ì¹˜
 * - í•„ìš” ì‹œ enableSwap=trueë¡œ 1íšŒë§Œ ë¹ ë¥¸ ìŠ¤ì™‘(ê°œì„ ë˜ë©´ ì ìš©)
 *
 * ì‚¬ìš©:
 * const teamNames = ['Blue','Red','Yellow'];
 * const result = allocateTeamsSimple(players, teamNames, true); // true=1íšŒ ìŠ¤ì™‘
 */
function allocateTeamsSimple(players, teamNames, enableSwap) {
  if (!Array.isArray(teamNames) || teamNames.length !== 3) {
    throw new Error('teamNamesëŠ” ì •í™•íˆ 3ê°œì—¬ì•¼ í•©ë‹ˆë‹¤.');
  }
  if (!Array.isArray(players) || players.length === 0) {
    throw new Error('playersê°€ ë¹„ì–´ ìˆìŠµë‹ˆë‹¤.');
  }

  // 1) íŒ€ë³„ ëª©í‘œ ì¸ì›(ì¿¼í„°) ê³„ì‚°
  const quotas = computeQuotasFor3(players.length); // ì˜ˆ: [6,6,6] ë˜ëŠ” [7,7,7] ë“±

  // 2) ì´ˆê¸° ìƒíƒœ
  const sorted = players.map(p => ({ ...p, power: Number(p.power) || 0 }))
                        .sort((a, b) => b.power - a.power); // ë†’ì€ íŒŒì›Œ ìš°ì„ 
  const teamState = teamNames.map((name, i) => ({
    name, players: [], sumPower: 0, target: quotas[i]
  }));

  // 3) ê°„ë‹¨ ê·¸ë¦¬ë”” ë°°ì¹˜
  for (const pl of sorted) {
    // ì•„ì§ ì¸ì› ë¯¸ë‹¬ì¸ íŒ€ ì¤‘ í•©ê³„ íŒŒì›Œê°€ ë‚®ì€ íŒ€
    const candidate = teamState
      .filter(t => t.players.length < t.target)
      .sort((a, b) => {
        if (a.sumPower !== b.sumPower) return a.sumPower - b.sumPower;     // íŒŒì›Œ ë‚®ì€ íŒ€ ìš°ì„ 
        const ar = a.target - a.players.length, br = b.target - b.players.length;
        if (ar !== br) return br - ar;                                      // ë‚¨ì€ ìŠ¬ë¡¯ ë§ì€ íŒ€
        return String(a.name).localeCompare(String(b.name));                // ì•ˆì •ì  íƒ€ì´ë¸Œë ˆì´ì»¤
      })[0];

    if (!candidate) throw new Error('ë°°ì¹˜í•  íŒ€ì´ ì—†ìŠµë‹ˆë‹¤(ì¿¼í„° ê³„ì‚° í™•ì¸).');
    candidate.players.push(pl);
    candidate.sumPower += pl.power;
  }

  // 4) ì„ íƒ: 1íšŒë§Œ ì•„ì£¼ ê°„ë‹¨í•œ ìŠ¤ì™‘ìœ¼ë¡œ ê· í˜• ê°œì„  ì‹œë„
  if (enableSwap) {
    quickOneSwap(teamState);
  }

  // 5) ê²°ê³¼ ì •ë¦¬
  const out = {};
  for (const t of teamState) {
    out[t.name] = { players: t.players, sumPower: t.sumPower, size: t.players.length };
  }
  return out;
}

/**
 * 18ëª…â†’[6,6,6], 21ëª…â†’[7,7,7], ê·¸ ì™¸ëŠ” ì°¨ì´ â‰¤ 1 ë˜ë„ë¡ ë¶„ë°°
 */
function computeQuotasFor3(total) {
  if (total === 18) return [6, 6, 6];
  if (total === 21) return [7, 7, 7];
  const base = Math.floor(total / 3);
  const rem = total % 3; // 0,1,2
  const q = [base, base, base];
  for (let i = 0; i < rem; i++) q[i] += 1; // ì• íŒ€ë¶€í„° +1
  // ì•ˆì „ í™•ì¸: ì°¨ì´ 1 ì´ˆê³¼ ê¸ˆì§€
  const maxQ = Math.max(...q), minQ = Math.min(...q);
  if (maxQ - minQ > 1) throw new Error('ì¿¼í„° ê³„ì‚° ì˜¤ë¥˜: íŒ€ ê°„ ì¸ì› ì°¨ì´ê°€ 1ì„ ì´ˆê³¼í•©ë‹ˆë‹¤.');
  return q;
}

/**
 * ì•„ì£¼ ë¹ ë¥¸ 1íšŒ ìŠ¤ì™‘ ì‹œë„(í‘œì¤€í¸ì°¨ê°€ ì¤„ì–´ë“œëŠ” ê²½ìš°ì—ë§Œ êµí™˜)
 * - ìµœê°•íŒ€ê³¼ ìµœì•½íŒ€ ì‚¬ì´ì—ì„œë§Œ 1ìŒ êµí™˜
 */
function quickOneSwap(teamState) {
  const sums = () => teamState.map(t => t.sumPower);
  const baseStd = std(sums());
  // ìµœì•½/ìµœê°• íŒ€
  const ordered = [...teamState].sort((a, b) => a.sumPower - b.sumPower);
  const weak = ordered[0];
  const strong = ordered[ordered.length - 1];
  if (!weak.players.length || !strong.players.length) return;

  // í›„ë³´ë¥¼ ë§ì´ ëŒì§€ ì•Šê³ , ê°•íŒ€ì˜ ì•½í•œ ìª½ vs ì•½íŒ€ì˜ ê°•í•œ ìª½ ìœ„ì£¼ë¡œë§Œ ê°„ë‹¨ íƒìƒ‰
  const strongSorted = [...strong.players].sort((a, b) => a.power - b.power); // ì•½í•œâ†’ê°•í•œ
  const weakSorted   = [...weak.players].sort((a, b) => b.power - a.power);   // ê°•í•œâ†’ì•½í•œ
  const topK = Math.min(3, strongSorted.length, weakSorted.length);

  let best = null, bestStd = baseStd;
  for (let i = 0; i < topK; i++) {
    const a = strongSorted[i]; // ê°•íŒ€ì˜ ìƒëŒ€ì  ì•½í•œ ì„ ìˆ˜
    const b = weakSorted[i];   // ì•½íŒ€ì˜ ìƒëŒ€ì  ê°•í•œ ì„ ìˆ˜
    if (!a || !b) continue;

    const strongNew = strong.sumPower - a.power + b.power;
    const weakNew   = weak.sumPower   - b.power + a.power;

    const newSums = teamState.map(t => {
      if (t === strong) return strongNew;
      if (t === weak)   return weakNew;
      return t.sumPower;
    });
    const newStd = std(newSums);
    if (newStd + 1e-9 < bestStd) {
      bestStd = newStd;
      best = { a, b };
    }
  }

  if (best) {
    const ai = strong.players.indexOf(best.a);
    const bi = weak.players.indexOf(best.b);
    if (ai >= 0 && bi >= 0) {
      strong.players[ai] = best.b;
      weak.players[bi]   = best.a;
      strong.sumPower = strong.sumPower - best.a.power + best.b.power;
      weak.sumPower   = weak.sumPower   - best.b.power + best.a.power;
    }
  }
}

/**
 * í‘œì¤€í¸ì°¨(ê°„ë‹¨ ë²„ì „)
 */
function std(arr) {
  if (!arr.length) return 0;
  const m = arr.reduce((s, v) => s + v, 0) / arr.length;
  const v = arr.reduce((s, v) => s + (v - m) * (v - m), 0) / arr.length;
  return Math.sqrt(v);
}


function allocateBalanced(players, teams, teamNames) {
    players.sort((a, b) => b.power - a.power);
    
    // íƒìš• ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ ì´ˆê¸° ë°°ë¶„
    players.forEach(player => {
        const teamPowers = teamNames.map(name => ({
            name: name,
            power: teams[name].players.reduce((sum, p) => sum + p.power, 0),
            count: teams[name].players.length
        })).sort((a, b) => {
            if (a.count !== b.count) return a.count - b.count; // ì¸ì› ìš°ì„ 
            return a.power - b.power; // ëŠ¥ë ¥ì¹˜ ì°¨ìˆœ
        });
        
        teams[teamPowers[0].name].players.push(player);
    });
    
    // ê°„ë‹¨í•œ ê· í˜• ì¡°ì • (5íšŒ)
    for (let i = 0; i < 5; i++) {
        const teamPowers = teamNames.map(name => ({
            name: name,
            power: teams[name].players.reduce((sum, p) => sum + p.power, 0),
            players: teams[name].players
        })).sort((a, b) => a.power - b.power);
        
        const weakest = teamPowers[0];
        const strongest = teamPowers[2];
        const gap = strongest.power - weakest.power;
        
        if (gap <= 20) break; // ì¶©ë¶„íˆ ê· í˜•ì¡í˜
        
        // ê°„ë‹¨í•œ êµí™˜
        if (strongest.players.length > 0 && weakest.players.length > 0) {
            const weakInStrong = strongest.players.reduce((prev, curr) => 
                prev.power < curr.power ? prev : curr
            );
            const strongInWeak = weakest.players.reduce((prev, curr) => 
                prev.power > curr.power ? prev : curr
            );
            
            if (weakInStrong.power < strongInWeak.power) {
                const strongIdx = strongest.players.indexOf(weakInStrong);
                const weakIdx = weakest.players.indexOf(strongInWeak);
                
                strongest.players[strongIdx] = strongInWeak;
                weakest.players[weakIdx] = weakInStrong;
            }
        }
    }
}

// 2. CCP ìˆœìœ„ê¸°ë°˜ìš© ìƒˆ í•¨ìˆ˜ ì¶”ê°€ (CCP 1ì  ì´ë‚´)
function allocateCcpBased(players, teams, teamNames) {
   console.log("CCP ê¸°ë°˜ ë°°ë¶„ ì‹œì‘");
    console.log("ì„ ìˆ˜ë³„ CCP:", players.map(p => `${p.name}:${p.power}`));
    players.sort((a, b) => b.power - a.power);
    
    // ì´ˆê¸° ê· ë“± ë°°ë¶„
    players.forEach((player, i) => {
        teams[teamNames[i % teamNames.length]].players.push(player);
    });
    
    // CCP ê· í˜• ì¡°ì • (ìµœëŒ€ 50íšŒ)
    for (let i = 0; i < 50; i++) {
        const teamStats = teamNames.map(name => ({
            name: name,
            avgCcp: teams[name].players.reduce((sum, p) => sum + p.power, 0) / teams[name].players.length,
            players: teams[name].players
        })).sort((a, b) => a.avgCcp - b.avgCcp);
        
        const weakest = teamStats[0];
        const strongest = teamStats[2];
        const ccpGap = strongest.avgCcp - weakest.avgCcp;
        
        if (ccpGap <= 1) break; // CCP 1ì  ì´ë‚´ë©´ ì¢…ë£Œ
        
        // ì„ ìˆ˜ êµí™˜
        if (strongest.players.length > 0 && weakest.players.length > 0) {
            const weakInStrong = strongest.players.reduce((prev, curr) => 
                prev.power < curr.power ? prev : curr
            );
            const strongInWeak = weakest.players.reduce((prev, curr) => 
                prev.power > curr.power ? prev : curr
            );
            
            if (weakInStrong.power < strongInWeak.power) {
                const strongIdx = strongest.players.indexOf(weakInStrong);
                const weakIdx = weakest.players.indexOf(strongInWeak);
                
                strongest.players[strongIdx] = strongInWeak;
                weakest.players[weakIdx] = weakInStrong;
            } else {
                break;
            }
        }
    }
}


// 1. allocateMpBased í•¨ìˆ˜ êµì²´ (í˜„ì¬ ë¶ˆê· ë“± ë°°ë¶„ ë¬¸ì œ)
function allocateMpBased(players, teams, teamNames) {
    players.sort((a, b) => b.power - a.power);
    
    players.forEach(player => {
        const teamPowers = teamNames.map(name => ({
            name: name,
            power: teams[name].players.reduce((sum, p) => sum + p.power, 0),
            count: teams[name].players.length
        })).sort((a, b) => {
            // â˜… ì¸ì›ìˆ˜ ìš°ì„  ë¹„êµë¡œ ë³€ê²½
            if (a.count !== b.count) return a.count - b.count; // ì¸ì› ì ì€ íŒ€ ìš°ì„ 
            return a.power - b.power; // ì¸ì› ê°™ìœ¼ë©´ ì•½í•œ íŒ€ ìš°ì„ 
        });
        
        teams[teamPowers[0].name].players.push(player);
    });
}

// 2. allocateMpPerGameBased í•¨ìˆ˜ êµì²´ (ì§€ê·¸ì¬ê·¸ ë°©ì‹ ê°œì„ )
function allocateMpPerGameBased(players, teams, teamNames) {
    players.sort((a, b) => b.power - a.power);
    
    // ê°œì„ ëœ ì§€ê·¸ì¬ê·¸: ë” ê· í˜•ì¡íŒ íŒ¨í„´
    let assignments = [];
    let teamIndex = 0;
    let direction = 1;
    
    players.forEach(player => {
        assignments.push({ player, teamIndex });
        
        if (direction === 1) {
            teamIndex++;
            if (teamIndex >= teamNames.length) {
                teamIndex = teamNames.length - 1;
                direction = -1;
            }
        } else {
            teamIndex--;
            if (teamIndex < 0) {
                teamIndex = 0;
                direction = 1;
            }
        }
    });
    
    // ë°°ë¶„ ì‹¤í–‰
    assignments.forEach(assignment => {
        teams[teamNames[assignment.teamIndex]].players.push(assignment.player);
    });
}

// 1. allocateWinRateBased í•¨ìˆ˜ ìˆ˜ì • (ìŠ¹ë¥  2% ì´ë‚´, CCP 3ì  ì´ë‚´)
function allocateWinRateBased(players, teams, teamNames) {
    players.sort((a, b) => b.power - a.power);
    
    // ì´ˆê¸° ê· ë“± ë°°ë¶„
    players.forEach((player, i) => {
        teams[teamNames[i % teamNames.length]].players.push(player);
    });
    
    // ìŠ¹ë¥  ê· í˜• ì¡°ì • (ìµœëŒ€ 50íšŒ)
    for (let i = 0; i < 50; i++) {
        const teamStats = teamNames.map(name => ({
            name: name,
            avgWinRate: teams[name].players.reduce((sum, p) => sum + p.power, 0) / teams[name].players.length,
            players: teams[name].players
        })).sort((a, b) => a.avgWinRate - b.avgWinRate);
        
        const weakest = teamStats[0];
        const strongest = teamStats[2];
        const winRateGap = strongest.avgWinRate - weakest.avgWinRate;
        
        if (winRateGap <= 2) break; // ìŠ¹ë¥  2% ì´ë‚´ë©´ ì¢…ë£Œ
        
        // ì„ ìˆ˜ êµí™˜
        if (strongest.players.length > 0 && weakest.players.length > 0) {
            const weakInStrong = strongest.players.reduce((prev, curr) => 
                prev.power < curr.power ? prev : curr
            );
            const strongInWeak = weakest.players.reduce((prev, curr) => 
                prev.power > curr.power ? prev : curr
            );
            
            if (weakInStrong.power < strongInWeak.power) {
                const strongIdx = strongest.players.indexOf(weakInStrong);
                const weakIdx = weakest.players.indexOf(strongInWeak);
                
                strongest.players[strongIdx] = strongInWeak;
                weakest.players[weakIdx] = weakInStrong;
            } else {
                break;
            }
        }
    }
}

// 4. ìƒˆë¡œìš´ ê· í˜• ì²´í¬ í•¨ìˆ˜ (ë””ë²„ê¹…ìš©)
function checkTeamBalance(teams, teamNames) {
    const teamPowers = teamNames.map(name => ({
        name: name,
        power: teams[name].players.reduce((sum, p) => sum + p.power, 0),
        count: teams[name].players.length
    }));
    
    console.log('íŒ€ ê· í˜• ì²´í¬:');
    teamPowers.forEach(team => {
        console.log(`${team.name}: ${team.power.toFixed(1)} (${team.count}ëª…)`);
    });
    
    const maxPower = Math.max(...teamPowers.map(t => t.power));
    const minPower = Math.min(...teamPowers.map(t => t.power));
    const gap = maxPower - minPower;
    
    console.log(`ìµœëŒ€ ëŠ¥ë ¥ì¹˜ ì°¨ì´: ${gap.toFixed(1)} ${gap <= 15 ? '(ê· í˜•ì¡íŒ)' : '(ë¶ˆê· í˜•)'}`);
    
    return gap <= 15;
}

// 6. ì™„ì „ ëœë¤
function allocateRandom(players, teams, teamNames) {
    const shuffled = players.sort(() => 0.5 - Math.random());
    shuffled.forEach((player, i) => {
        teams[teamNames[i % teamNames.length]].players.push(player);
    });
}


// ì£¼ì¥/ë¶€ì£¼ì¥ ëœë¤ ì„¤ì •
function assignCaptains(teams) {
    Object.keys(teams).forEach(teamName => {
        const playersInTeam = teams[teamName].players;
        if (playersInTeam.length > 0) {
            // ëœë¤ìœ¼ë¡œ ì£¼ì¥ ì„ ì •
            const randomCaptainIndex = Math.floor(Math.random() * playersInTeam.length);
            const captain = playersInTeam[randomCaptainIndex];
            teams[teamName].captain = captain.name;
            
            // ì£¼ì¥ì„ ì œì™¸í•œ ë‚˜ë¨¸ì§€ ì„ ìˆ˜ë“¤
            const others = playersInTeam.filter((p, index) => index !== randomCaptainIndex);
            if (others.length > 0) {
                // ëœë¤ìœ¼ë¡œ ë¶€ì£¼ì¥ ì„ ì •
                const randomViceIndex = Math.floor(Math.random() * others.length);
                const viceCaptain = others[randomViceIndex];
                teams[teamName].viceCaptain = viceCaptain.name;
            } else {
                teams[teamName].viceCaptain = null;
            }
        } else {
            teams[teamName].captain = null;
            teams[teamName].viceCaptain = null;
        }
    });
}
